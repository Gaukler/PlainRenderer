#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "global.inc"
#include "screenToWorld.inc"
#include "linearDepth.inc"
#include "lightBuffer.inc"
#include "SDF.inc"
#include "sky.inc"
#include "sampling.inc"
#include "noise.inc"
#include "SphericalHarmonics.inc"
#include "colorConversion.inc"
#include "sdfCulling.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, rgba16f) 	uniform image2D imageOut_Y_SH;
layout(set=1, binding = 1, rg16f) 		uniform image2D imageOut_CoCg;
layout(set=1, binding = 2) 	            uniform texture2D depthTexture;
layout(set=1, binding = 3) 	            uniform texture2D normalTexture;
layout(set=1, binding = 4)				uniform texture2D skyLut;

layout(set=1, binding = 5, std430) buffer lightStorageBuffer{
    LightBuffer lightBuffer;
};

layout(set=1, binding = 6, std430) buffer sdfInstanceBuffer{
    uint instanceCount;
	uint padding1;
	uint padding2;
	uint padding3;
	SDFInstance sdfInstances[];
};

layout(set=1, binding = 7, std430) buffer cameraCulledTileBuffer{
    CulledInstancesPerTile cameraCulledTiles[];
};

layout(set=1, binding = 8, std430) buffer shadowCulledTileBuffer{
    CulledInstancesPerTile shadowCulledTiles[];
};

layout(set=1, binding = 9, std140) uniform shadowFrustumInfoBuffer{
	ShadowFrustum shadowFrustum;
};

layout(set=2, binding = 0) uniform texture3D[] textures;

void main(){
	ivec2 iUV = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = iUV / vec2(imageSize(imageOut_Y_SH));
	float depth = texture(sampler2D(depthTexture, g_sampler_nearestClamp), uv).r;
	float depthLinear = linearizeDepth(depth, g_nearPlane, g_farPlane);

	vec2 pixelNDC = uv * 2 - 1;
	pixelNDC.y *= -1;
	vec3 V = calculateViewDirectionFromPixel(pixelNDC, g_cameraForward.xyz, g_cameraUp.xyz, g_cameraRight.xyz, g_cameraTanFovHalf, g_cameraAspectRatio);
	vec3 pWorld = g_cameraPosition.xyz + V / dot(V, -g_cameraForward.xyz) * depthLinear;

	vec4 result_Y_SH = vec4(0.f);
	vec2 result_CoCg = vec2(0.f);

	vec2 noiseUV = vec2(iUV) / textureSize(sampler2D(g_noiseTexture, g_sampler_linearRepeat), 0);
	vec2 xi = texture(sampler2D(g_noiseTexture, g_sampler_nearestRepeat), noiseUV).rg;

	vec3 normalTexel = texture(sampler2D(normalTexture, g_sampler_nearestClamp), uv).rgb;
	vec3 N = normalTexel * 2 - 1;
	vec3 rayOrigin = pWorld + N * 0.2;

	vec3 L = importanceSampleCosine(xi, N);

	TraceResult traceResult;
	traceResult.hit = false;
	traceResult.closestHitDistance = 10000.f;

	ivec2 tileUV = iUV / ivec2(cullingTileSize);
	uint tileIndex = tileIndexFromTileUV(tileUV);

	//iterate all objects in culling tile
	CulledInstancesPerTile cullingTile = cameraCulledTiles[tileIndex];
	for(int i = 0; i < cullingTile.objectCount; i++){
		SDFInstance instance = sdfInstances[cullingTile.indices[i]];
		traceRayTroughSDFInstance(instance, rayOrigin, textures[instance.sdfTextureIndex], L, traceResult);
	}

	float shadow = 1.f;

	ivec2 shadowTileUV = computeShadowTileUV(traceResult.hitPos, shadowFrustum);
	uint shadowTileIndex = computeShadowTileIndexFromUV(shadowTileUV);

	bool validShadowTile = isShadowTileValid(shadowTileUV);

	if(traceResult.hit && validShadowTile){

		CulledInstancesPerTile shadowTile = shadowCulledTiles[shadowTileIndex];
		for(int i = 0; i < shadowTile.objectCount; i++){
			SDFInstance instance = sdfInstances[shadowTile.indices[i]];

			bool shadowHit = shadowRay(instance, traceResult.hitPos, traceResult.N, g_sunDirection.xyz, textures[instance.sdfTextureIndex]);
			if(shadowHit){
				shadow = 0.f;
				break;
			}
		}
	}
	else{
		shadow = 0.f;
	}

	vec3 hitColor;

	if(traceResult.hit){
		vec3 sunLight = lightBuffer.sunStrengthExposed * lightBuffer.sunColor;
		sunLight *= shadow; 
		float NoL = clamp(dot(traceResult.N, g_sunDirection.xyz), 0, 1);
		hitColor = traceResult.albedo * sunLight * NoL;
	}
	else{
		hitColor = sampleSkyLut(L, skyLut);
	}

	vec3 YCoCg = linearToYCoCg(hitColor);

	result_Y_SH += YCoCg.x * directionToSH_L1(L);
	result_CoCg += YCoCg.yz;

	//multiplication by pi because PDF = NoL / pi
	//division by PDF is multiplication with pi / NoL
	//NoL is reduced with NoL from rendering equation 
	result_Y_SH *= pi;
	result_CoCg *= pi;

	imageStore(imageOut_Y_SH, iUV, result_Y_SH);
	imageStore(imageOut_CoCg, iUV, vec4(result_CoCg, vec2(0.f)));
}