#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "screenToWorld.inc"
#include "linearDepth.inc"
#include "lightBuffer.inc"
#include "SDF.inc"
#include "sky.inc"
#include "sampling.inc"
#include "noise.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f) 	uniform image2D imageOut;
layout(set=1, binding = 1) 	                uniform texture3D sdfTexture;
layout(set=1, binding = 2) 	                uniform texture3D materialTexture;
layout(set=1, binding = 3) 	                uniform texture2D depthTexture;
layout(set=1, binding = 4) 	                uniform texture2D normalTexture;

layout(set=1, binding = 5, std140)			uniform sdfVolumeData{
    VolumeInfo sdfInfo;
};

layout(set=1, binding = 6, std430) buffer lightStorageBuffer{
    LightBuffer lightBuffer;
};

layout(set=1, binding = 7) uniform texture2D skyLut;

void main(){
	ivec2 imageCoordinate = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = imageCoordinate / vec2(g_screenResolution);
	float depth = texture(sampler2D(depthTexture, g_sampler_linearRepeat), uv).r;
	float depthLinear = linearizeDepth(depth, g_nearPlane, g_farPlane);

	vec2 pixelNDC = uv * 2 - 1;
	pixelNDC.y *= -1;
	vec3 V = calculateViewDirectionFromPixel(pixelNDC, g_cameraForward.xyz, g_cameraUp.xyz, g_cameraRight.xyz, g_cameraTanFovHalf, g_cameraAspectRatio);
	vec3 pWorld = g_cameraPosition.xyz + V / dot(V, -g_cameraForward.xyz) * depthLinear;

	vec3 normalTexel = texture(sampler2D(normalTexture, g_sampler_linearRepeat), uv).rgb;
	vec3 N = normalTexel * 2 - 1;

	float sdfThreshold = 0.12f;

	vec3 sdfMin = sdfInfo.offset.xyz - sdfInfo.extends.xyz * 0.5f;
	vec3 sdfMax = sdfInfo.offset.xyz + sdfInfo.extends.xyz * 0.5f;

	vec3 rayOrigin = pWorld + N * 0.2;
	if(sampleSDF(worldPositionToVolume(rayOrigin, sdfInfo.offset.xyz, sdfInfo.extends.xyz), sdfTexture) < sdfThreshold){
		//bias not enough to move point out of mesh
		//ignore
		imageStore(imageOut, imageCoordinate, vec4(vec3(0, 0, 0), 1.f));
		return;
	}

	vec3 color = vec3(0.f);
	
	vec2 noiseUV = vec2(imageCoordinate) / textureSize(sampler2D(g_noiseTexture, g_sampler_linearRepeat), 0);
	float noise = texture(sampler2D(g_noiseTexture, g_sampler_nearestRepeat), noiseUV).r; 
	noise *= 2 * pi;

	int samples = 24;
	for(int i = 0; i < samples; i++){
        vec2 xi = hammersley2d(4, samples);
		vec3 L = importanceSampleCosineRotated(xi, N, noise);

		SDFTrace trace = sdfTrace(rayOrigin, L, sdfInfo, sdfTexture, sdfThreshold, sdfMin, sdfMax);

		if(trace.hit){
			vec3 ambient = vec3(0.f);
			color += shadeHit(trace, sdfInfo, sdfTexture, materialTexture, sdfThreshold, ambient, sdfMin, sdfMax, 
				lightBuffer.sunColor, lightBuffer.sunStrengthExposed);
		}
		else{
			color += sampleSkyLut(L, skyLut);
		}
	}
	color /= float(samples);
	//multiplication by pi because PDF = NoL / pi
	//division by PDF is multiplication with pi / NoL
	//NoL is reduced with NoL from rendering equation 
	color *= pi;
	imageStore(imageOut, imageCoordinate, vec4(vec3(color), 1.f));
}