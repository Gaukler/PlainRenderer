#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "sdfCulling.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

//already culled against shadow frustum
layout(set=1, binding = 0, std430) buffer culledSdfInstanceBuffer{
    uint culledInstanceCount;
	uint culledInstanceIndices[];
};

layout(set=1, binding = 1, std430) buffer worldBBInstanceBuffer{
	BoundingBox instanceBBs[];
};

layout(set=1, binding = 2, std430) buffer perTileInstanceBuffer{
    CulledInstancesPerTile cullingTiles[];
};

layout(set=1, binding = 3, std140) uniform shadowFrustumInfoBuffer{
	ShadowFrustum shadowFrustum;
};

int shadowTileCount = 32;

void main(){

	uvec2 tileUV = gl_GlobalInvocationID.xy;
	uint tileIndex = tileUV.x + tileUV.y * shadowTileCount;

	if(any(greaterThanEqual(tileUV, ivec2(shadowTileCount)))){
		return;
	}

	vec2 tileExtendsWorld = shadowFrustum.extends / shadowTileCount;
	vec3 rayStart = 
		shadowFrustum.right * shadowFrustum.offset.x +
		shadowFrustum.up	* shadowFrustum.offset.y +		
		(tileUV.x + 0.5f) * tileExtendsWorld.x * shadowFrustum.right +
		(tileUV.y + 0.5f) * tileExtendsWorld.y * shadowFrustum.up;

	float cylinderRadius = max(tileExtendsWorld.x, tileExtendsWorld.y) * 0.5;

	vec3 L = -g_sunDirection.xyz;

	cullingTiles[tileIndex].objectCount = 0;

	for(int i = 0; i < culledInstanceCount; i++){
		BoundingBox bb = instanceBBs[culledInstanceIndices[i]];

		vec3 boundingSphereCenter = (bb.bbMax + bb.bbMin) * 0.5f;
		vec3 bbExtends = (bb.bbMax - bb.bbMin) * 0.5f;
		float boundingSphereRadius = max(max(bbExtends.x, bbExtends.y), bbExtends.z);

		float projection = dot(boundingSphereCenter - rayStart, L);

		float d = distance(boundingSphereCenter, rayStart + L * projection);

		if(d < boundingSphereRadius + cylinderRadius){
			cullingTiles[tileIndex].indices[cullingTiles[tileIndex].objectCount] = culledInstanceIndices[i];
			cullingTiles[tileIndex].objectCount++;
		}
	}
}