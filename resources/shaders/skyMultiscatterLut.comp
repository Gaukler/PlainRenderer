#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "sky.inc"
#include "global.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f) uniform image2D multiscatterLut;
layout(set=1, binding = 1) uniform texture2D transmissionLut;
layout(set=1, binding = 2) uniform sampler skySampler;

layout(set=1, binding = 3, std140) uniform atmosphereSettingsBuffer{
    AtmosphereSettings atmosphereSettings;
};

void main(){
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
	
    float x = uv.x / float(imageSize(multiscatterLut).x);
    float y = uv.y / float(imageSize(multiscatterLut).y);
    
    float height = mix(0, atmosphereSettings.atmosphereHeight, x);
    vec3 P = vec3(0, -height - atmosphereSettings.earthRadius, 0);
    vec3 earthCenter = vec3(0);
    
    float upDot = y * 2 - 1;
    vec3 L = vec3(0, -upDot, sqrt(1 - (upDot * upDot)));
    
    vec3 L_2nd = vec3(0);
    vec3 f_ms = vec3(0);
    
    float isotropicPhase = 1.f / (4.f * 3.1415);
    
    const float sampleCountSqrt = 8;
    for(float i = 0; i < 8; i++){
        for(float j = 0; j < 8; j++){
            
            float theta =     3.1415 * i / sampleCountSqrt;
            float phi   = 2 * 3.1415 * j / sampleCountSqrt;
            
            vec3 V = vec3(sin(theta) * cos(theta), -cos(theta), sin(theta) * sin(theta));
            
            float innerSampleCount = 20;
            
            vec3 inscattered = vec3(0.f);
            Intersection intersection = rayEarthIntersection(P, V, earthCenter, atmosphereSettings.earthRadius, atmosphereSettings.atmosphereHeight);
            vec3 currentPosition = P;
            float stepSize = intersection.distance / innerSampleCount;
            
            vec3 L_f = vec3(0.f);
            
            vec3 earthAlbedo = vec3(0.3);
            vec3 earthHitNormal = normalize(intersection.pos - earthCenter);
            float earthNoL = clamp(dot(earthHitNormal, L), 0, 1);
            
            vec2 lutUV = computeLutUV(0, atmosphereSettings.atmosphereHeight, intersection.pos, earthCenter, L);
            vec3 transmissionToIntersection = texture(sampler2D(transmissionLut, skySampler), lutUV).rgb;
            vec3 incomingLight = transmissionToIntersection;
            vec3 earthLit = earthAlbedo / 3.1415 * incomingLight * earthNoL;
            vec3 direct = intersection.hitEarth ? earthLit : vec3(0.f);
            
            vec3 transmission = vec3(1.f);
            
            for(int i = 0; i < innerSampleCount; i++){
                
                currentPosition += stepSize * V;
                
                float currentHeight = max(distance(currentPosition, earthCenter) - atmosphereSettings.earthRadius, 0);
                
                AtmosphereCoefficients coefficients = calculateCoefficients(height, atmosphereSettings);

                vec3 scatteringCo = coefficients.scatterRayleigh + coefficients.scatterMie;
                 
                //light arriving at point
                vec2 lutUV = computeLutUV(currentHeight, atmosphereSettings.atmosphereHeight, currentPosition, earthCenter, L);
                vec3 transmissionSun = texture(sampler2D(transmissionLut, skySampler), lutUV).rgb;
                
                vec3 inscatteredLight = scatteringCo * transmissionSun * isotropicPhase;
                
                //inscattering from light at point
                vec3 scatterIntegral = integrateInscattering(inscatteredLight, coefficients.extinction, stepSize);
                inscattered += scatterIntegral * transmission;
                 
                vec3 coefficientIntegral = integrateInscattering(scatteringCo, coefficients.extinction, stepSize);
                L_f += coefficientIntegral * transmission;
                
                transmission *= exp(-coefficients.extinction * stepSize);
            }   
            direct *= transmission;
            
            f_ms += L_f * sin(theta);  //isotropic phase function reduced with integral over sphere(factor 4 x pi)
            L_2nd += (direct * transmission + inscattered) * sin(theta); //isotropic phase function reduced with integral over sphere(factor 4 x pi)
        }
    }  
    f_ms /= sampleCountSqrt * sampleCountSqrt; 
    L_2nd /= sampleCountSqrt * sampleCountSqrt;
    
    vec3 F_ms = vec3(1.f) / (1.f - f_ms);
    vec3 multiscatter = L_2nd * F_ms;
	imageStore(multiscatterLut, uv, vec4(multiscatter, 0.f));
}