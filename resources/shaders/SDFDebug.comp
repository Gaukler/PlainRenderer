#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f)	uniform image2D imageOut;
layout(set=1, binding = 1)					uniform texture3D sceneSDF;
layout(set=1, binding = 2, std140)			uniform sdfVolumeData{
    vec4 sdfVolumeExtends;
    vec4 sdfVolumeOffset;
};

vec3 worldToSDF(vec3 w){
	vec3 samplePos = w - sdfVolumeOffset.xyz;		//in range[-extend/2, extend/2]
    samplePos = samplePos / sdfVolumeExtends.xyz;   //in range [-0.5, 0.5]
    samplePos += 0.5f;  
	return samplePos;
}

float sampleSDF(vec3 uv){
	return texture(sampler3D(sceneSDF, g_sampler_linearClamp), uv).r;
}

vec3 normalFromSDF(vec3 uv){
	float extendsMax = max(sdfVolumeExtends.x, max(sdfVolumeExtends.y, sdfVolumeExtends.z));
	vec3 extendsNormalized = sdfVolumeExtends.xyz / extendsMax;
	vec3 epsilon = vec3(0.025) / extendsNormalized; //voxels are anisotropic so epsilon must be scaled per axis
	return normalize(vec3(
		sampleSDF(uv + vec3(epsilon.x, 0, 0)) - sampleSDF(uv - vec3(epsilon.x, 0, 0)),
		sampleSDF(uv + vec3(0, epsilon.y, 0)) - sampleSDF(uv - vec3(0, epsilon.y, 0)),
		sampleSDF(uv + vec3(0, 0, epsilon.z)) - sampleSDF(uv - vec3(0, 0, epsilon.z))
	));
}

bool isPointInAABB(vec3 p, vec3 aabbMin, vec3 aabbMax){
	return 
		p.x >= aabbMin.x &&
		p.y >= aabbMin.y &&
		p.z >= aabbMin.z &&
		p.x <= aabbMax.x &&
		p.y <= aabbMax.y &&
		p.z <= aabbMax.z;
}

void main(){
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	vec2 pixelCoor = (vec2(uv.xy) / g_screenResolution - 0.5) * 2;
	pixelCoor.y *= -1;

	vec3 V = -g_cameraForward.xyz;
	V += g_cameraUp.xyz * g_cameraTanFovHalf * pixelCoor.y;
	V += g_cameraRight.xyz * g_cameraTanFovHalf * g_cameraAspectRatio * pixelCoor.x;
	V = normalize(V);

	vec3 samplePosWorld = g_cameraPosition.xyz + g_nearPlane * V;	//in range [0, 1]

	vec3 sdfMin = sdfVolumeOffset.xyz - sdfVolumeExtends.xyz * 0.5f;
	vec3 sdfMax = sdfVolumeOffset.xyz + sdfVolumeExtends.xyz * 0.5f;

    if(!isPointInAABB(samplePosWorld, sdfMin, sdfMax)){

		bool hitAABB = false;

		//search for bounding box intersection
		float intersection =  samplePosWorld.x < sdfVolumeOffset.x ? sdfMin.x : sdfMax.x;
		float t = 100000;	//will be replaced by min
		float tx = (intersection - samplePosWorld.x) / V.x;
		vec3 planeIntersection = samplePosWorld + tx * V;
		if(	tx > 0 && 
			planeIntersection.y >= sdfMin.y && 
			planeIntersection.y <= sdfMax.y &&
			planeIntersection.z >= sdfMin.z && 
			planeIntersection.z <= sdfMax.z){
			t = min(t, tx);
			hitAABB = true;
		}

		intersection =  samplePosWorld.y < sdfVolumeOffset.y ? sdfMin.y : sdfMax.y;
		float ty = (intersection - samplePosWorld.y) / V.y;
		planeIntersection = samplePosWorld + ty * V;
		if(	ty > 0 && 
			planeIntersection.x >= sdfMin.x && 
			planeIntersection.x <= sdfMax.x &&
			planeIntersection.z >= sdfMin.z && 
			planeIntersection.z <= sdfMax.z){
			t = min(t, ty);
			hitAABB = true;
		}

		intersection =  samplePosWorld.z < sdfVolumeOffset.z ? sdfMin.z : sdfMax.z;
		float tz = (intersection - samplePosWorld.z) / V.z;
		planeIntersection = samplePosWorld + tz * V;
		if(	tz > 0 && 
			planeIntersection.x >= sdfMin.x && 
			planeIntersection.x <= sdfMax.x &&
			planeIntersection.y >= sdfMin.y && 
			planeIntersection.y <= sdfMax.y){
			t = min(t, tz);
			hitAABB = true;
		}

		if(hitAABB){
			samplePosWorld += t * V;
		}
		else{
			//early out
			imageStore(imageOut, uv, vec4(0));
			return;
		}
	}

	float steps = 0;
	float sampleCount = 20.f;
	bool hit = false;

	ivec3 sdfResolution = textureSize(sampler3D(sceneSDF, g_sampler_linearClamp), 0);
	float sdfThreshold = length(sdfVolumeExtends.xyz / vec3(sdfResolution)) * 0.1;
	sdfThreshold = 0.04;
	const float minStepSize = sdfThreshold * 0.8f;

	for(int i = 0; i < sampleCount; i++){
		vec3 samplePos = worldToSDF(samplePosWorld);
		float sdf = texture(sampler3D(sceneSDF, g_sampler_linearClamp), samplePos).r;

		hit = sdf < sdfThreshold;
		
		if(hit){
			break;
		}

		float stepSize = max(abs(sdf), minStepSize);
		samplePosWorld += V * stepSize;
		steps++;
	}
	vec3 color = hit ? 0.5f * normalFromSDF(worldToSDF(samplePosWorld)) + 0.5f : vec3(0);
	imageStore(imageOut, uv, vec4(color, 1.f));
}