#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "volume.inc"
#include "lightBuffer.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f)	uniform image2D imageOut;
layout(set=1, binding = 1)					uniform texture3D sceneSDF;
layout(set=1, binding = 2, std140)			uniform sdfVolumeData{
    vec4 sdfVolumeExtends;
    vec4 sdfVolumeOffset;
};
layout(set=1, binding = 3)					uniform texture3D materialTexture;

layout(set=1, binding = 4, std430) buffer lightStorageBuffer{
    LightBuffer lightBuffer;
};

float sampleSDF(vec3 uv){
	return texture(sampler3D(sceneSDF, g_sampler_linearClamp), uv).r;
}

vec3 normalFromSDF(vec3 uv){
	float extendsMax = max(sdfVolumeExtends.x, max(sdfVolumeExtends.y, sdfVolumeExtends.z));
	vec3 extendsNormalized = sdfVolumeExtends.xyz / extendsMax;
	vec3 epsilon = vec3(0.1f) / textureSize(sampler3D(sceneSDF, g_sampler_linearClamp), 0) / extendsNormalized; //voxels are anisotropic so epsilon must be scaled per axis
	return normalize(vec3(
		sampleSDF(uv + vec3(epsilon.x, 0, 0)) - sampleSDF(uv - vec3(epsilon.x, 0, 0)),
		sampleSDF(uv + vec3(0, epsilon.y, 0)) - sampleSDF(uv - vec3(0, epsilon.y, 0)),
		sampleSDF(uv + vec3(0, 0, epsilon.z)) - sampleSDF(uv - vec3(0, 0, epsilon.z))
	));
}

bool isPointInAABB(vec3 p, vec3 aabbMin, vec3 aabbMax){
	return 
		p.x >= aabbMin.x &&
		p.y >= aabbMin.y &&
		p.z >= aabbMin.z &&
		p.x <= aabbMax.x &&
		p.y <= aabbMax.y &&
		p.z <= aabbMax.z;
}

//binary shadowing function
//returns factor to be multiplied with light
//soft shadows would require a higher resolution sdf
//might revisit if sdf quality is improved
float shadowRay(vec3 startPosWorld, float sdfThreshold){
	vec3 sdfMin = sdfVolumeOffset.xyz - sdfVolumeExtends.xyz * 0.5f;
	vec3 sdfMax = sdfVolumeOffset.xyz + sdfVolumeExtends.xyz * 0.5f;
	int sampleCount = 80;

	vec3 samplePosWorld = startPosWorld;

	for(int i = 0; i < sampleCount; i++){
		vec3 samplePos = worldPositionToVolume(samplePosWorld, sdfVolumeOffset.xyz, sdfVolumeExtends.xyz);

		float sdf = texture(sampler3D(sceneSDF, g_sampler_linearClamp), samplePos).r;
		bool hit = sdf < sdfThreshold;

		if(hit){
			return 0.f;
		}

		float stepSize = sdf;
		samplePosWorld += g_sunDirection.xyz * stepSize;

		if(!isPointInAABB(samplePosWorld, sdfMin, sdfMax)){
			1.f;
		}
	}
	return 1.f;	
}

void main(){
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	vec2 pixelCoor = (vec2(uv.xy) / g_screenResolution - 0.5) * 2;
	pixelCoor.y *= -1;

	vec3 V = -g_cameraForward.xyz;
	V += g_cameraUp.xyz * g_cameraTanFovHalf * pixelCoor.y;
	V += g_cameraRight.xyz * g_cameraTanFovHalf * g_cameraAspectRatio * pixelCoor.x;
	V = normalize(V);

	vec3 samplePosWorld = g_cameraPosition.xyz + g_nearPlane * V;	//in range [0, 1]

	vec3 sdfMin = sdfVolumeOffset.xyz - sdfVolumeExtends.xyz * 0.5f;
	vec3 sdfMax = sdfVolumeOffset.xyz + sdfVolumeExtends.xyz * 0.5f;

    if(!isPointInAABB(samplePosWorld, sdfMin, sdfMax)){

		bool hitAABB = false;

		//search for bounding box intersection
		float intersection =  samplePosWorld.x < sdfVolumeOffset.x ? sdfMin.x : sdfMax.x;
		float t = 100000;	//will be replaced by min
		float tx = (intersection - samplePosWorld.x) / V.x;
		vec3 planeIntersection = samplePosWorld + tx * V;
		if(	tx > 0 && 
			planeIntersection.y >= sdfMin.y && 
			planeIntersection.y <= sdfMax.y &&
			planeIntersection.z >= sdfMin.z && 
			planeIntersection.z <= sdfMax.z){
			t = min(t, tx);
			hitAABB = true;
		}

		intersection =  samplePosWorld.y < sdfVolumeOffset.y ? sdfMin.y : sdfMax.y;
		float ty = (intersection - samplePosWorld.y) / V.y;
		planeIntersection = samplePosWorld + ty * V;
		if(	ty > 0 && 
			planeIntersection.x >= sdfMin.x && 
			planeIntersection.x <= sdfMax.x &&
			planeIntersection.z >= sdfMin.z && 
			planeIntersection.z <= sdfMax.z){
			t = min(t, ty);
			hitAABB = true;
		}

		intersection =  samplePosWorld.z < sdfVolumeOffset.z ? sdfMin.z : sdfMax.z;
		float tz = (intersection - samplePosWorld.z) / V.z;
		planeIntersection = samplePosWorld + tz * V;
		if(	tz > 0 && 
			planeIntersection.x >= sdfMin.x && 
			planeIntersection.x <= sdfMax.x &&
			planeIntersection.y >= sdfMin.y && 
			planeIntersection.y <= sdfMax.y){
			t = min(t, tz);
			hitAABB = true;
		}

		if(hitAABB){
			samplePosWorld += t * V;
		}
		else{
			//early out
			imageStore(imageOut, uv, vec4(0));
			return;
		}
	}

	float steps = 0;
	float sampleCount = 45.f;
	bool hit = false;

	ivec3 sdfResolution = textureSize(sampler3D(sceneSDF, g_sampler_linearClamp), 0);
	float sdfThreshold = 0.12f;
	const float minStepSize = 0.f;//sdfThreshold;

	float sdf = 0.f;
	float sdfLast = 0.f;

	for(int i = 0; i < sampleCount; i++){
		vec3 samplePos = worldPositionToVolume(samplePosWorld, sdfVolumeOffset.xyz, sdfVolumeExtends.xyz);

		sdfLast = sdf;
		sdf = texture(sampler3D(sceneSDF, g_sampler_linearClamp), samplePos).r;

		hit = sdf < sdfThreshold;
		
		if(hit){
			break;
		}

		float stepSize = max(abs(sdf), minStepSize);
		samplePosWorld += V * stepSize;
		steps++;
	}

	vec3 originalHitPos = samplePosWorld;

	//normal calculation is based on original position
	//the modified position is more accurate but on thin objects the modification might push the position to the other side
	//because of this normals are more consistent when using the original position
	vec3 hitOriginalNormalized = worldPositionToVolume(originalHitPos, sdfVolumeOffset.xyz, sdfVolumeExtends.xyz);
	vec3 N = normalFromSDF(hitOriginalNormalized);

	//assume surface is planar and calculate hit using geometric series
	//see: "GPU-based clay simulation and ray-tracing tech in Claybook", page 25
	float lastStepSize = sdf / (1.f - (sdf - sdfLast));
	vec3 modifiedHitPos = originalHitPos + V * lastStepSize;
	vec3 hitModifiedNormalized = worldPositionToVolume(modifiedHitPos, sdfVolumeOffset.xyz, sdfVolumeExtends.xyz);

	//material lookup uses the modified position as it is more accurate
	vec4 albedoTexel = texture(sampler3D(materialTexture, g_sampler_linearClamp), hitModifiedNormalized);
	vec3 albedo = albedoTexel.rgb / max(albedoTexel.a, 0.00001);

	//shadow ray origin is offset into normal direction to avoid self intersection
	float shadow = shadowRay(originalHitPos + N * sdfThreshold, sdfThreshold);
	vec3 sunLight = shadow * dot(N, g_sunDirection.xyz) * lightBuffer.sunStrengthExposed * lightBuffer.sunColor;
	vec3 ambient = vec3(0.1);
	vec3 color = albedo * (sunLight + ambient);

	//color = N * 0.5 + 0.5;	//visualize normals
	imageStore(imageOut, uv, vec4(color, 1.f));
}