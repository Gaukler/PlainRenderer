#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "global.inc"
#include "screenToWorld.inc"
#include "lightBuffer.inc"
#include "SDF.inc"
#include "sky.inc"
#include "sdfCulling.inc"
#include "noise.inc" //temp for debugging

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f)	uniform image2D imageOut;
layout(set=1, binding = 1, std430) buffer lightStorageBuffer{
    LightBuffer lightBuffer;
};
layout(set=1, binding = 2) uniform texture2D skyLut;
layout(set=1, binding = 3, std430) buffer sdfInstanceBuffer{
    uint instanceCount;
	uint padding1;
	uint padding2;
	uint padding3;
	SDFInstance sdfInstances[];
};

layout(set=1, binding = 4, std430) buffer cameraCulledTileBuffer{
    CulledInstancesPerTile cameraCulledTiles[];
};

layout(set=1, binding = 5, std430) buffer shadowCulledTileBuffer{
    CulledInstancesPerTile shadowCulledTiles[];
};

layout(set=1, binding = 6, std430) buffer cameraCulledSdfInstanceBuffer{
    uint cameraCulledInstanceCount;
	uint cameraCulledInstanceIndices[];
};

layout(set=1, binding = 7, std430) buffer shadowCulledSdfInstanceBuffer{
    uint shadowCulledInstanceCount;
	uint shadowCulledInstanceIndices[];
};

layout(set=1, binding = 8, std140) uniform shadowFrustumInfoBuffer{
	ShadowFrustum shadowFrustum;
};

layout(set=2, binding = 0) uniform texture3D[] textures;

void main(){
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	vec2 pixelCoor = (vec2(uv.xy) / g_screenResolution - 0.5) * 2;
	pixelCoor.y *= -1;
	vec3 V = calculateViewDirectionFromPixel(pixelCoor, g_cameraForward.xyz, g_cameraUp.xyz, g_cameraRight.xyz, g_cameraTanFovHalf, g_cameraAspectRatio);

	//FIXME: get tile size from CPU
	ivec2 tileUV = uv / ivec2(cullingTileSize);
	uint tileIndex = tileIndexFromTileUV(tileUV);

	vec3 rayStart = g_cameraPosition.xyz + g_nearPlane * V;	//in range [0, 1]
	vec3 rayEnd = rayStart + g_farPlane * V;
	vec3 rayDirectionWorld = normalize(rayEnd - rayStart);
		
	TraceResult traceResult;
	traceResult.hit = false;
	traceResult.closestHitDistance = 10000.f;

	//iterate all objects in culling tile
	CulledInstancesPerTile cullingTile = cameraCulledTiles[tileIndex];
	for(int instanceIndex = 0; instanceIndex < cullingTile.objectCount; instanceIndex++){
		SDFInstance instance = sdfInstances[cullingTile.indices[instanceIndex]];
		
		traceRayTroughSDFInstance(instance, rayStart, textures[instance.sdfTextureIndex], rayDirectionWorld, traceResult);
	}

	float shadow = 1.f;

	uint shadowTileIndex = computeShadowTileIndex(traceResult.hitPos, shadowFrustum);
	CulledInstancesPerTile shadowTile = shadowCulledTiles[shadowTileIndex];

	if(traceResult.hit){
		for(int i = 0; i < shadowTile.objectCount; i++){
			SDFInstance instance = sdfInstances[shadowTile.indices[i]];

			bool shadowHit = shadowRay(instance, traceResult.hitPos, traceResult.N, g_sunDirection.xyz, textures[instance.sdfTextureIndex]);
			if(shadowHit){
				shadow = 0.f;
				break;
			}
		}
	}
	

	if(traceResult.hit){
		//vec3 color = vec3(hitCount / 128.f + 0.1);
		//vec3 color = vec3(cullingTiles[tileIndex].objectCount / 40.f);
		//vec3 color = N*0.5+0.5;

		vec3 sunLight = lightBuffer.sunStrengthExposed * lightBuffer.sunColor;
		sunLight *= shadow; 
		vec3 ambient = vec3(0.15f);
		float NoL = clamp(dot(traceResult.N, g_sunDirection.xyz), 0, 1);
		vec3 color = traceResult.albedo * (ambient + sunLight * NoL);
		//visualize different shadow tiles
		//uint test = wang_hash(shadowTileIndex);
		//color = vec3(rand(test));

		//mark tile indices outside of valid range
		//color = all(greaterThanEqual(shadowTileUV, ivec2(0))) ? color : vec3(0, 0, 1);
		//color = all(lessThan(shadowTileUV, ivec2(shadowTileCount1D))) ? color : vec3(0, 1, 1);

		imageStore(imageOut, uv, vec4(color, 1.f));

		//visualize overflowing shadow tiles
		if(shadowCulledTiles[shadowTileIndex].objectCount >= 40){
			imageStore(imageOut, uv, vec4(vec3(0, 1, 0), 0));
		}
	}
	else{
		vec3 color = sampleSkyLut(V, skyLut);
		//vec3 color = vec3(hitCount / 128.f);
		imageStore(imageOut, uv, vec4(color, 0));
	}

	//visualize overflowing camera tiles
	if(cameraCulledTiles[tileIndex].objectCount >= maxObjectsPerTile){
		imageStore(imageOut, uv, vec4(vec3(1, 0, 0), 0));
	}
}