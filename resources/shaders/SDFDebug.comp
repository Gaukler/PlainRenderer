#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "global.inc"
#include "screenToWorld.inc"
#include "lightBuffer.inc"
#include "SDF.inc"
#include "sky.inc"
#include "sdfCulling.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct SDFInstance{
	vec3	localExtends;
	uint	sdfTextureIndex;
	vec3	meanAlbedo;
	float	padding;
	mat4x4	worldToLocal;
};

layout(set=1, binding = 0, r11f_g11f_b10f)	uniform image2D imageOut;
layout(set=1, binding = 1, std430) buffer lightStorageBuffer{
    LightBuffer lightBuffer;
};
layout(set=1, binding = 2) uniform texture2D skyLut;
layout(set=1, binding = 3, std430) buffer sdfInstanceBuffer{
    uint instanceCount;
	uint padding1;
	uint padding2;
	uint padding3;
	SDFInstance sdfInstances[];
};

layout(set=1, binding = 4, std430) buffer perTileInstanceBuffer{
    CulledInstancesPerTile cullingTiles[];
};

layout(set=1, binding = 5, std430) buffer cameraCulledSdfInstanceBuffer{
    uint cameraCulledInstanceCount;
	uint cameraCulledInstanceIndices[];
};

layout(set=1, binding = 6, std430) buffer shadowCulledSdfInstanceBuffer{
    uint shadowCulledInstanceCount;
	uint shadowCulledInstanceIndices[];
};

layout(set=2, binding = 0) uniform texture3D[] textures;

void main(){
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	int hitCount = 0;
	bool hit = false;
	float closestHitDistance = 10000.f;
	vec3 N;
	vec3 albedo;
	vec3 hitPos;

	vec2 pixelCoor = (vec2(uv.xy) / g_screenResolution - 0.5) * 2;
	pixelCoor.y *= -1;
	vec3 V = calculateViewDirectionFromPixel(pixelCoor, g_cameraForward.xyz, g_cameraUp.xyz, g_cameraRight.xyz, g_cameraTanFovHalf, g_cameraAspectRatio);

	//FIXME: get tile size from CPU
	ivec2 tileUV = uv / ivec2(cullingTileSize);
	uint tileIndex = tileIndexFromTileUV(tileUV);

	{
		vec3 rayStart = g_cameraPosition.xyz + g_nearPlane * V;	//in range [0, 1]
		vec3 rayEnd = rayStart + g_farPlane * V;
		vec3 rayDirectionWorld = normalize(rayEnd - rayStart);

		//code for iterating coarser culling groups for debugging
		//iterate over all scene objects
		//for(int instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++){
		//	SDFInstance instance = sdfInstances[instanceIndex];
		//iterate over all objects within camera frustum
		//for(int instanceIndex = 0; instanceIndex < cameraCulledInstanceCount; instanceIndex++){
		//	SDFInstance instance = sdfInstances[cameraCulledInstanceIndices[instanceIndex]];
		
		//iterate all objects in culling tile
		CulledInstancesPerTile cullingTile = cullingTiles[tileIndex];
		for(int instanceIndex = 0; instanceIndex < cullingTile.objectCount; instanceIndex++){
			SDFInstance instance = sdfInstances[cullingTile.indices[instanceIndex]];

			vec3 rayStartLocal	= (instance.worldToLocal * vec4(rayStart, 1)).xyz;
			vec3 rayEndLocal	= (instance.worldToLocal * vec4(rayEnd, 1)).xyz;

			vec3 rayDirection = rayEndLocal - rayStartLocal;
			rayDirection /= length(rayDirection);

			vec3 sdfMaxLocal = instance.localExtends * 0.5;
			vec3 sdfMinLocal = -sdfMaxLocal;

			float hitDistance = 0.f;

			if(!isPointInAABB(rayStartLocal, sdfMinLocal, sdfMaxLocal)){
				HitResult aabbHit = rayAABBIntersection(rayStartLocal, rayDirection, sdfMinLocal, sdfMaxLocal);
		
				if(aabbHit.hit){
					//move sample point to intersection
					rayStartLocal += (aabbHit.t) * rayDirection;
					hitDistance = aabbHit.t;
				}
				else{
					//ray missed AABB
					continue;
				}
			}

			vec3 localSamplePos = rayStartLocal;

			float distanceThreshold = 0.1f;
			ivec3 sdfResolution = textureSize(sampler3D(textures[instance.sdfTextureIndex], g_sampler_linearClamp), 0);
			distanceThreshold = length(instance.localExtends / sdfResolution) * 0.25;

			float dLast = 0.f;	//last step distance
			float d = 0.f;

			for(int i = 0; i < 128; i++){

				vec3 localExtendsHalf = instance.localExtends * 0.5;
				localExtendsHalf += 0.01; //bias
				if(any(greaterThan(localSamplePos, localExtendsHalf)) || any(lessThan(localSamplePos, -localExtendsHalf))){
					break;
				}

				vec3 sampleUV = localSamplePos / instance.localExtends + 0.5;
			
				dLast = d;
				d = texture(sampler3D(textures[instance.sdfTextureIndex], g_sampler_linearClamp), sampleUV).r; 

				if(d < distanceThreshold){
					hit = true;
					if(hitDistance < closestHitDistance){
						closestHitDistance = hitDistance;
						hitCount = i;

						float lastStepSize = d / (1.f - (d - dLast));

						//assume surface is planar and calculate hit using geometric series
						//see: "GPU-based clay simulation and ray-tracing tech in Claybook", page 25
						localSamplePos += rayDirection * lastStepSize;
						sampleUV = localSamplePos / instance.localExtends + 0.5;

						N = normalFromSDF(sampleUV, instance.localExtends, textures[instance.sdfTextureIndex]);
						N = transpose(mat3(instance.worldToLocal)) * N;	//worldToLocal is rotation matrix, so transpose is inverse
						albedo = pow(instance.meanAlbedo, vec3(2.2f));
						hitPos = rayStart + rayDirectionWorld * (hitDistance + lastStepSize);
					}
					break;
				}
				hitCount = i;
				localSamplePos += rayDirection * abs(d);
				hitDistance += abs(d);
			}
		}
	}

	float shadow = 1.f;

	//iterate over all instances in scene
	//for(int instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++){
	//	SDFInstance instance = sdfInstances[instanceIndex];

	//iterate over all instances within shadow frustum
	for(int instanceIndex = 0; instanceIndex < shadowCulledInstanceCount; instanceIndex++){
		SDFInstance instance = sdfInstances[shadowCulledInstanceIndices[instanceIndex]];
		
		float distanceThreshold = 0.1f;
		ivec3 sdfResolution = textureSize(sampler3D(textures[instance.sdfTextureIndex], g_sampler_linearClamp), 0);
		distanceThreshold = length(instance.localExtends / sdfResolution) * 0.25;

		vec3 L = g_sunDirection.xyz;
		vec3 shadowStart = hitPos + L * distanceThreshold * 2.5;
		vec3 shadowEnd = shadowStart + L * 20;

		vec3 rayStartLocal	= (instance.worldToLocal * vec4(shadowStart, 1)).xyz;
		vec3 rayEndLocal	= (instance.worldToLocal * vec4(shadowEnd, 1)).xyz;

		vec3 rayDirection = rayEndLocal - rayStartLocal;
		rayDirection /= length(rayDirection);

		vec3 sdfMaxLocal = instance.localExtends * 0.5;
		vec3 sdfMinLocal = -sdfMaxLocal;

		bool shadowHit = false;

		if(!isPointInAABB(rayStartLocal, sdfMinLocal, sdfMaxLocal)){
			HitResult aabbHit = rayAABBIntersection(rayStartLocal, rayDirection, sdfMinLocal, sdfMaxLocal);
		
			if(aabbHit.hit){
				//move sample point to intersection
				rayStartLocal += aabbHit.t * rayDirection;
			}
			else{
				//ray missed AABB
				continue;
			}
		}
		
		vec3 localSamplePos = rayStartLocal;

		for(int i = 0; i < 128; i++){

			vec3 localExtendsHalf = instance.localExtends * 0.5;
			localExtendsHalf += 0.01; //bias
			if(any(greaterThan(localSamplePos, localExtendsHalf)) || any(lessThan(localSamplePos, -localExtendsHalf))){
				break;
			}

			vec3 sampleUV = localSamplePos / instance.localExtends + 0.5;
			
			float d = texture(sampler3D(textures[instance.sdfTextureIndex], g_sampler_linearClamp), sampleUV).r; 

			if(d < distanceThreshold){
				shadowHit = true;
				shadow = 0.f;
				break;
			}
			localSamplePos += rayDirection * d;
		}
		if(shadowHit){
			break;
		}
	}

	if(hit){
		//vec3 color = vec3(hitCount / 128.f + 0.1);
		//vec3 color = vec3(cullingTiles[tileIndex].objectCount / 40.f);
		//vec3 color = N*0.5+0.5;
		vec3 sunLight = lightBuffer.sunStrengthExposed * lightBuffer.sunColor;
		sunLight *= shadow; 
		vec3 ambient = vec3(0.15f);
		float NoL = clamp(dot(N, g_sunDirection.xyz), 0, 1);
		vec3 color = albedo * (ambient + sunLight * NoL);
		imageStore(imageOut, uv, vec4(color, 1.f));
	}
	else{
		vec3 color = sampleSkyLut(V, skyLut);
		//vec3 color = vec3(hitCount / 128.f);
		imageStore(imageOut, uv, vec4(color, 0));
	}
	//visualize overflowing tiles
	if(cullingTiles[tileIndex].objectCount >= 40){
		imageStore(imageOut, uv, vec4(vec3(1, 0, 0), 0));
	}
}