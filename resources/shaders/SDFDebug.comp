#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "volume.inc"
#include "lightBuffer.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f)	uniform image2D imageOut;
layout(set=1, binding = 1)					uniform texture3D sceneSDF;
layout(set=1, binding = 2, std140)			uniform sdfVolumeData{
    vec4 sdfVolumeExtends;
    vec4 sdfVolumeOffset;
};
layout(set=1, binding = 3)					uniform texture3D materialTexture;

layout(set=1, binding = 4, std430) buffer lightStorageBuffer{
    LightBuffer lightBuffer;
};

float sampleSDF(vec3 uv){
	return texture(sampler3D(sceneSDF, g_sampler_linearClamp), uv).r;
}

vec3 normalFromSDF(vec3 uv){
	float extendsMax = max(sdfVolumeExtends.x, max(sdfVolumeExtends.y, sdfVolumeExtends.z));
	vec3 extendsNormalized = sdfVolumeExtends.xyz / extendsMax;
	vec3 epsilon = vec3(0.1f) / textureSize(sampler3D(sceneSDF, g_sampler_linearClamp), 0) / extendsNormalized; //voxels are anisotropic so epsilon must be scaled per axis
	return normalize(vec3(
		sampleSDF(uv + vec3(epsilon.x, 0, 0)) - sampleSDF(uv - vec3(epsilon.x, 0, 0)),
		sampleSDF(uv + vec3(0, epsilon.y, 0)) - sampleSDF(uv - vec3(0, epsilon.y, 0)),
		sampleSDF(uv + vec3(0, 0, epsilon.z)) - sampleSDF(uv - vec3(0, 0, epsilon.z))
	));
}

bool isPointInAABB(vec3 p, vec3 aabbMin, vec3 aabbMax){
	return 
		p.x >= aabbMin.x &&
		p.y >= aabbMin.y &&
		p.z >= aabbMin.z &&
		p.x <= aabbMax.x &&
		p.y <= aabbMax.y &&
		p.z <= aabbMax.z;
}

//binary shadowing function
//aabb min and max are min and max of sdf aabb, used to determine if shadow ray left scene
//returns factor to be multiplied with light
//soft shadows would require a higher resolution sdf
//might revisit if sdf quality is improved
float shadowRay(vec3 startPosWorld, float sdfThreshold, vec3 aabbMin, vec3 aabbMax){
	int sampleCount = 80;

	vec3 samplePosWorld = startPosWorld;

	for(int i = 0; i < sampleCount; i++){
		vec3 samplePos = worldPositionToVolume(samplePosWorld, sdfVolumeOffset.xyz, sdfVolumeExtends.xyz);

		float d = sampleSDF(samplePos);
		bool hit = d < sdfThreshold;

		if(hit){
			return 0.f;
		}

		float stepSize = d;
		samplePosWorld += g_sunDirection.xyz * stepSize;

		if(!isPointInAABB(samplePosWorld, aabbMin, aabbMax)){
			1.f;
		}
	}
	//not enough samples, assume lit
	return 1.f;	
}

vec3 calculateViewDirectionFromPixel(vec2 pixelCoor){
	vec3 V = -g_cameraForward.xyz;
	V += g_cameraUp.xyz * g_cameraTanFovHalf * pixelCoor.y;
	V += g_cameraRight.xyz * g_cameraTanFovHalf * g_cameraAspectRatio * pixelCoor.x;
	return normalize(V);
}

struct HitResult{
	bool hit;
	float t;	//hit = origin + direction * t
};

HitResult rayAABBIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 aabbMin, vec3 aabbMax){

	HitResult result;
	result.hit = false;
	result.t = 100000;	//will be replaced by min

	//search for bounding box intersection
	float intersection =  rayOrigin.x < sdfVolumeOffset.x ? aabbMin.x : aabbMax.x;
	
	float tx = (intersection - rayOrigin.x) / rayDirection.x;
	vec3 planeIntersection = rayOrigin + tx * rayDirection;
	if(	tx > 0 && 
		planeIntersection.y >= aabbMin.y && 
		planeIntersection.y <= aabbMax.y &&
		planeIntersection.z >= aabbMin.z && 
		planeIntersection.z <= aabbMax.z){
		result.t = min(result.t, tx);
		result.hit = true;
	}

	intersection =  rayOrigin.y < sdfVolumeOffset.y ? aabbMin.y : aabbMax.y;
	float ty = (intersection - rayOrigin.y) / rayDirection.y;
	planeIntersection = rayOrigin + ty * rayDirection;
	if(	ty > 0 && 
		planeIntersection.x >= aabbMin.x && 
		planeIntersection.x <= aabbMax.x &&
		planeIntersection.z >= aabbMin.z && 
		planeIntersection.z <= aabbMax.z){
		result.t = min(result.t, ty);
		result.hit = true;
	}

	intersection =  rayOrigin.z < sdfVolumeOffset.z ? aabbMin.z : aabbMax.z;
	float tz = (intersection - rayOrigin.z) / rayDirection.z;
	planeIntersection = rayOrigin + tz * rayDirection;
	if(	tz > 0 && 
		planeIntersection.x >= aabbMin.x && 
		planeIntersection.x <= aabbMax.x &&
		planeIntersection.y >= aabbMin.y && 
		planeIntersection.y <= aabbMax.y){
		result.t = min(result.t, tz);
		result.hit = true;
	}
	return result;
}

void main(){
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	vec2 pixelCoor = (vec2(uv.xy) / g_screenResolution - 0.5) * 2;
	pixelCoor.y *= -1;
	vec3 V = calculateViewDirectionFromPixel(pixelCoor);

	vec3 samplePosWorld = g_cameraPosition.xyz + g_nearPlane * V;	//in range [0, 1]

	vec3 sdfMin = sdfVolumeOffset.xyz - sdfVolumeExtends.xyz * 0.5f;
	vec3 sdfMax = sdfVolumeOffset.xyz + sdfVolumeExtends.xyz * 0.5f;

	//check if ray is outside of scene AABB
    if(!isPointInAABB(samplePosWorld, sdfMin, sdfMax)){
		HitResult aabbHit = rayAABBIntersection(samplePosWorld, V, sdfMin, sdfMax);
		
		if(aabbHit.hit){
			//move sample point to intersection
			samplePosWorld += aabbHit.t * V;
		}
		else{
			//ray missed AABB
			imageStore(imageOut, uv, vec4(0));
			return;
		}
	}
	
	bool hit = false;
	float d = 0.f;		//distance to surface
	float dLast = 0.f;	//last step distance

	int sampleCount = 45;
	float sdfThreshold = 0.12f;

	for(int i = 0; i < sampleCount; i++){
		vec3 samplePos = worldPositionToVolume(samplePosWorld, sdfVolumeOffset.xyz, sdfVolumeExtends.xyz);

		dLast = d;
		d = sampleSDF(samplePos);

		hit = d < sdfThreshold;
		
		if(hit){
			break;
		}
		samplePosWorld += V * abs(d);
	}

	vec3 originalHitPos = samplePosWorld;

	//normal calculation is based on original position
	//the modified position is more accurate but on thin objects the modification might push the position to the other side
	//because of this normals are more consistent when using the original position
	vec3 hitOriginalNormalized = worldPositionToVolume(originalHitPos, sdfVolumeOffset.xyz, sdfVolumeExtends.xyz);
	vec3 N = normalFromSDF(hitOriginalNormalized);

	//assume surface is planar and calculate hit using geometric series
	//see: "GPU-based clay simulation and ray-tracing tech in Claybook", page 25
	float lastStepSize = d / (1.f - (d - dLast));
	vec3 modifiedHitPos = originalHitPos + V * lastStepSize;
	vec3 hitModifiedNormalized = worldPositionToVolume(modifiedHitPos, sdfVolumeOffset.xyz, sdfVolumeExtends.xyz);

	//material lookup uses the modified position as it is more accurate
	vec4 albedoTexel = texture(sampler3D(materialTexture, g_sampler_linearClamp), hitModifiedNormalized);
	vec3 albedo = albedoTexel.rgb / max(albedoTexel.a, 0.00001);

	//shadow ray origin is offset into normal direction to avoid self intersection
	vec3 shadowRayOrigin = originalHitPos + N * sdfThreshold;
	float shadow = shadowRay(shadowRayOrigin, sdfThreshold, sdfMin, sdfMax);

	vec3 sunLight = shadow * dot(N, g_sunDirection.xyz) * lightBuffer.sunStrengthExposed * lightBuffer.sunColor;
	vec3 ambient = vec3(0.1);
	vec3 color = albedo * (sunLight + ambient);

	//color = N * 0.5 + 0.5;	//visualize normals
	imageStore(imageOut, uv, vec4(color, 1.f));
}