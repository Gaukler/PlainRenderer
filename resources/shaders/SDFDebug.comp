#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "volume.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f)	uniform image2D imageOut;
layout(set=1, binding = 1)					uniform texture3D sceneSDF;
layout(set=1, binding = 2, std140)			uniform sdfVolumeData{
    vec4 sdfVolumeExtends;
    vec4 sdfVolumeOffset;
};
layout(set=1, binding = 3)					uniform texture3D materialTexture;

float sampleSDF(vec3 uv){
	return texture(sampler3D(sceneSDF, g_sampler_linearClamp), uv).r;
}

vec3 normalFromSDF(vec3 uv){
	float extendsMax = max(sdfVolumeExtends.x, max(sdfVolumeExtends.y, sdfVolumeExtends.z));
	vec3 extendsNormalized = sdfVolumeExtends.xyz / extendsMax;
	vec3 epsilon = vec3(0.3f) / textureSize(sampler3D(sceneSDF, g_sampler_linearClamp), 0) / extendsNormalized; //voxels are anisotropic so epsilon must be scaled per axis
	return normalize(vec3(
		sampleSDF(uv + vec3(epsilon.x, 0, 0)) - sampleSDF(uv - vec3(epsilon.x, 0, 0)),
		sampleSDF(uv + vec3(0, epsilon.y, 0)) - sampleSDF(uv - vec3(0, epsilon.y, 0)),
		sampleSDF(uv + vec3(0, 0, epsilon.z)) - sampleSDF(uv - vec3(0, 0, epsilon.z))
	));
}

bool isPointInAABB(vec3 p, vec3 aabbMin, vec3 aabbMax){
	return 
		p.x >= aabbMin.x &&
		p.y >= aabbMin.y &&
		p.z >= aabbMin.z &&
		p.x <= aabbMax.x &&
		p.y <= aabbMax.y &&
		p.z <= aabbMax.z;
}

void main(){
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	vec2 pixelCoor = (vec2(uv.xy) / g_screenResolution - 0.5) * 2;
	pixelCoor.y *= -1;

	vec3 V = -g_cameraForward.xyz;
	V += g_cameraUp.xyz * g_cameraTanFovHalf * pixelCoor.y;
	V += g_cameraRight.xyz * g_cameraTanFovHalf * g_cameraAspectRatio * pixelCoor.x;
	V = normalize(V);

	vec3 samplePosWorld = g_cameraPosition.xyz + g_nearPlane * V;	//in range [0, 1]

	vec3 sdfMin = sdfVolumeOffset.xyz - sdfVolumeExtends.xyz * 0.5f;
	vec3 sdfMax = sdfVolumeOffset.xyz + sdfVolumeExtends.xyz * 0.5f;

    if(!isPointInAABB(samplePosWorld, sdfMin, sdfMax)){

		bool hitAABB = false;

		//search for bounding box intersection
		float intersection =  samplePosWorld.x < sdfVolumeOffset.x ? sdfMin.x : sdfMax.x;
		float t = 100000;	//will be replaced by min
		float tx = (intersection - samplePosWorld.x) / V.x;
		vec3 planeIntersection = samplePosWorld + tx * V;
		if(	tx > 0 && 
			planeIntersection.y >= sdfMin.y && 
			planeIntersection.y <= sdfMax.y &&
			planeIntersection.z >= sdfMin.z && 
			planeIntersection.z <= sdfMax.z){
			t = min(t, tx);
			hitAABB = true;
		}

		intersection =  samplePosWorld.y < sdfVolumeOffset.y ? sdfMin.y : sdfMax.y;
		float ty = (intersection - samplePosWorld.y) / V.y;
		planeIntersection = samplePosWorld + ty * V;
		if(	ty > 0 && 
			planeIntersection.x >= sdfMin.x && 
			planeIntersection.x <= sdfMax.x &&
			planeIntersection.z >= sdfMin.z && 
			planeIntersection.z <= sdfMax.z){
			t = min(t, ty);
			hitAABB = true;
		}

		intersection =  samplePosWorld.z < sdfVolumeOffset.z ? sdfMin.z : sdfMax.z;
		float tz = (intersection - samplePosWorld.z) / V.z;
		planeIntersection = samplePosWorld + tz * V;
		if(	tz > 0 && 
			planeIntersection.x >= sdfMin.x && 
			planeIntersection.x <= sdfMax.x &&
			planeIntersection.y >= sdfMin.y && 
			planeIntersection.y <= sdfMax.y){
			t = min(t, tz);
			hitAABB = true;
		}

		if(hitAABB){
			samplePosWorld += t * V;
		}
		else{
			//early out
			imageStore(imageOut, uv, vec4(0));
			return;
		}
	}

	float steps = 0;
	float sampleCount = 45.f;
	bool hit = false;

	ivec3 sdfResolution = textureSize(sampler3D(sceneSDF, g_sampler_linearClamp), 0);
	float sdfThreshold = length(sdfVolumeExtends.xyz / vec3(sdfResolution)) * 0.1;
	sdfThreshold = 0.13f;
	const float minStepSize = 0.f;//sdfThreshold;

	float sdf = 0.f;
	float sdfLast = 0.f;

	for(int i = 0; i < sampleCount; i++){
		vec3 samplePos = worldPositionToVolume(samplePosWorld, sdfVolumeOffset.xyz, sdfVolumeExtends.xyz);

		sdfLast = sdf;
		sdf = texture(sampler3D(sceneSDF, g_sampler_linearClamp), samplePos).r;

		hit = sdf < sdfThreshold;
		
		if(hit){
			break;
		}

		float stepSize = max(abs(sdf), minStepSize);
		samplePosWorld += V * stepSize;
		steps++;
	}

	//assume surface is planar and calculate hit using geometric series
	//see: "GPU-based clay simulation and ray-tracing tech in Claybook", page 25
	float lastStepSize = sdf / (1.f - (sdf - sdfLast));
	samplePosWorld += V * lastStepSize;

	vec3 hitNormalized = worldPositionToVolume(samplePosWorld, sdfVolumeOffset.xyz, sdfVolumeExtends.xyz);
	vec3 N = normalFromSDF(hitNormalized);

	vec3 color = hit ? 0.5f * N + 0.5f : vec3(0);

	vec4 albedoTexel = texture(sampler3D(materialTexture, g_sampler_linearClamp), hitNormalized);
	vec3 albedo = albedoTexel.rgb / max(albedoTexel.a, 0.00001);
	color = albedo;

	//color *= vec3(dot(N, g_sunDirection.xyz));
	//color = 0.05 * vec3(distance(samplePosWorld, g_cameraPosition.xyz));
	imageStore(imageOut, uv, vec4(color, 1.f));
}