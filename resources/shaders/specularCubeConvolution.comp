#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "cubemap.inc"
#include "sampling.inc"
#include "brdf.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f)	uniform imageCube	cubeOut;
layout(set=1, binding = 1) 					uniform textureCube	cubeTexture;
layout(set=1, binding = 2) 					uniform sampler 	cubeSampler;
layout(set=1, binding = 3) 					uniform indexBuffer{
	int mipLevel;
};

void main(){
	ivec3 storageCo = ivec3(gl_GlobalInvocationID.xyz);
	
	float maxMipLevel = 6.f;
	float r = 1.f * (float(mipLevel) / (maxMipLevel - 1));
	vec3 R = cubemapCoordinateToDirection(storageCo, imageSize(cubeOut).x);
	vec3 N = R;
	vec3 V = R;
	
	int samples = 1024;
	vec3 color = vec3(0.f);
	float weight = 0.f;
	
	for(int i = 0; i < samples; i++){
		
		vec2 random = hammersley2d(i, samples);
		vec3 H = importanceSampleGGX(random.x, random.y, r, N);
		vec3 L = 2.f * dot(V, H ) * H - V;

		float NoL = max(dot(N, L), 0.f);
		float NoH = max(dot(N, H), 0.f);
		float VoH = max(dot(V, H), 0.f);
		
		if(NoL > 0.f){
			/*
			compute load for pre-filtering
			*/
			float K = 4.f;
			float pdf = VoH / (D_GGX(NoH, r) * NoH);
			float omega_s = 1.f / pdf;
			float cubeRes = float(textureSize(samplerCube(cubeTexture, cubeSampler), 0).x);
			float omega_p = 4.f * 3.1415f / (6.f * cubeRes * cubeRes);
			
			float lod = 0.5f * log2(K * omega_s / omega_p);
			color += textureLod(samplerCube(cubeTexture, cubeSampler), L, max(lod, 0.f)).rgb * NoL;
			weight += NoL;
		}	
	}
	color /= weight;
	 
	imageStore(cubeOut, storageCo, vec4(color, 1.f));
}