#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "linearDepth.inc"
#include "screenToWorld.inc"
#include "noise.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, rgba16f) 	uniform image2D imageOut_Y_SH;
layout(set=1, binding = 1, rg16f) 		uniform image2D imageOut_CoCg;
layout(set=1, binding = 2) 				uniform texture2D texture_Y_SH;
layout(set=1, binding = 3) 				uniform texture2D texture_CoCg;
layout(set=1, binding = 4) 	            uniform texture2D depthTexture;
layout(set=1, binding = 5) 	            uniform texture2D normalTexture;
layout(set=1, binding = 6) 	            uniform texture2D edgeTexture;

vec3 pixelToWorld(vec2 uv){
	float depth = texture(sampler2D(depthTexture, g_sampler_linearRepeat), uv).r;
	float depthLinear = linearizeDepth(depth, g_nearPlane, g_farPlane);

	vec2 pixelNDC = uv * 2 - 1;
	pixelNDC.y *= -1;
	vec3 V = calculateViewDirectionFromPixel(pixelNDC, g_cameraForward.xyz, g_cameraUp.xyz, g_cameraRight.xyz, g_cameraTanFovHalf, g_cameraAspectRatio);
	return g_cameraPosition.xyz + V / dot(V, -g_cameraForward.xyz) * depthLinear;
}

void main(){

	vec2 poissonDisk[64];
poissonDisk[0] = vec2(-0.613392, 0.617481);
poissonDisk[1] = vec2(0.170019, -0.040254);
poissonDisk[2] = vec2(-0.299417, 0.791925);
poissonDisk[3] = vec2(0.645680, 0.493210);
poissonDisk[4] = vec2(-0.651784, 0.717887);
poissonDisk[5] = vec2(0.421003, 0.027070);
poissonDisk[6] = vec2(-0.817194, -0.271096);
poissonDisk[7] = vec2(-0.705374, -0.668203);
poissonDisk[8] = vec2(0.977050, -0.108615);
poissonDisk[9] = vec2(0.063326, 0.142369);
poissonDisk[10] = vec2(0.203528, 0.214331);
poissonDisk[11] = vec2(-0.667531, 0.326090);
poissonDisk[12] = vec2(-0.098422, -0.295755);
poissonDisk[13] = vec2(-0.885922, 0.215369);
poissonDisk[14] = vec2(0.566637, 0.605213);
poissonDisk[15] = vec2(0.039766, -0.396100);
poissonDisk[16] = vec2(0.751946, 0.453352);
poissonDisk[17] = vec2(0.078707, -0.715323);
poissonDisk[18] = vec2(-0.075838, -0.529344);
poissonDisk[19] = vec2(0.724479, -0.580798);
poissonDisk[20] = vec2(0.222999, -0.215125);
poissonDisk[21] = vec2(-0.467574, -0.405438);
poissonDisk[22] = vec2(-0.248268, -0.814753);
poissonDisk[23] = vec2(0.354411, -0.887570);
poissonDisk[24] = vec2(0.175817, 0.382366);
poissonDisk[25] = vec2(0.487472, -0.063082);
poissonDisk[26] = vec2(-0.084078, 0.898312);
poissonDisk[27] = vec2(0.488876, -0.783441);
poissonDisk[28] = vec2(0.470016, 0.217933);
poissonDisk[29] = vec2(-0.696890, -0.549791);
poissonDisk[30] = vec2(-0.149693, 0.605762);
poissonDisk[31] = vec2(0.034211, 0.979980);
poissonDisk[32] = vec2(0.503098, -0.308878);
poissonDisk[33] = vec2(-0.016205, -0.872921);
poissonDisk[34] = vec2(0.385784, -0.393902);
poissonDisk[35] = vec2(-0.146886, -0.859249);
poissonDisk[36] = vec2(0.643361, 0.164098);
poissonDisk[37] = vec2(0.634388, -0.049471);
poissonDisk[38] = vec2(-0.688894, 0.007843);
poissonDisk[39] = vec2(0.464034, -0.188818);
poissonDisk[40] = vec2(-0.440840, 0.137486);
poissonDisk[41] = vec2(0.364483, 0.511704);
poissonDisk[42] = vec2(0.034028, 0.325968);
poissonDisk[43] = vec2(0.099094, -0.308023);
poissonDisk[44] = vec2(0.693960, -0.366253);
poissonDisk[45] = vec2(0.678884, -0.204688);
poissonDisk[46] = vec2(0.001801, 0.780328);
poissonDisk[47] = vec2(0.145177, -0.898984);
poissonDisk[48] = vec2(0.062655, -0.611866);
poissonDisk[49] = vec2(0.315226, -0.604297);
poissonDisk[50] = vec2(-0.780145, 0.486251);
poissonDisk[51] = vec2(-0.371868, 0.882138);
poissonDisk[52] = vec2(0.200476, 0.494430);
poissonDisk[53] = vec2(-0.494552, -0.711051);
poissonDisk[54] = vec2(0.612476, 0.705252);
poissonDisk[55] = vec2(-0.578845, -0.768792);
poissonDisk[56] = vec2(-0.772454, -0.090976);
poissonDisk[57] = vec2(0.504440, 0.372295);
poissonDisk[58] = vec2(0.155736, 0.065157);
poissonDisk[59] = vec2(0.391522, 0.849605);
poissonDisk[60] = vec2(-0.620106, -0.328104);
poissonDisk[61] = vec2(0.789239, -0.419965);
poissonDisk[62] = vec2(-0.545396, 0.538133);
poissonDisk[63] = vec2(-0.178564, -0.596057);

	ivec2 iUV = ivec2(gl_GlobalInvocationID.xy);

	vec2 texelSize = 1.f / vec2(imageSize(imageOut_Y_SH));
	vec2 uv = (vec2(iUV) + 0.5f) * texelSize;

	vec3 pCenter = pixelToWorld(uv);
	vec3 pRight = pixelToWorld(uv + vec2(1, 0) * texelSize);
	vec3 pUp	= pixelToWorld(uv + vec2(0, 1) * texelSize);

	vec3 tangent	= normalize(pCenter - pRight);
	vec3 bitangent	= normalize(pCenter - pUp);
	vec3 N = normalize(cross(bitangent, tangent));
	N = 2 * texture(sampler2D(normalTexture, g_sampler_linearRepeat), uv).rgb - 1;

	int sampleCount = 24;

	vec4 result_Y_SH = vec4(0);
	vec2 result_CoCg = vec2(0);
	
	float weightTotal = 0.f;

	uint rngState = wang_hash(g_frameIndex);

	float depth = texture(sampler2D(depthTexture, g_sampler_linearRepeat), uv).r;
	float depthLinear = linearizeDepth(depth, g_nearPlane, g_farPlane);

	float radiusWorld = 0.5f;
	for(int i = 0; i < sampleCount; i++){

		float d = sqrt(rand(rngState));
		float angle = 2 * pi * rand(rngState);

		vec2 offset = vec2(cos(angle), sin(angle)) * d;

		//samples taken in world space
		//see "Exploring the Ray Traced Future in Metro Exodus"
		vec3 sampleWorld = pCenter + radiusWorld * (offset.x * tangent + offset.y * bitangent);
		vec4 sampleProjected = g_viewProjection * vec4(sampleWorld, 1);

		vec2 sampleUV = sampleProjected.xy / sampleProjected.w;
		sampleUV = sampleUV * 0.5 + 0.5;

		//uncomment to filter in screen space with 10 pixel radius
		//sampleUV = uv + offset * texelSize * 10;

		//mirror uv at borders
		sampleUV.x = sampleUV.x < 0.f ? uv.x - offset.x : sampleUV.x;
		sampleUV.y = sampleUV.y < 0.f ? uv.y - offset.y : sampleUV.y;
		sampleUV.x = sampleUV.x > 1.f ? uv.x - offset.x : sampleUV.x;
		sampleUV.y = sampleUV.y > 1.f ? uv.y - offset.y : sampleUV.y;

		//sample are weighed with distance from tangent plane
		//this avoids bleeding light from foreground/background
		//see "Exploring the Ray Traced Future in Metro Exodus"
		vec3 pixelWorld = pixelToWorld(sampleUV);
		float distanceToTangentPlane = abs(dot(N, pixelWorld - pCenter));
		float maxDistance = 0.1f;
		float weight = clamp(maxDistance / max(distanceToTangentPlane, 0.0001f), 0, 1);
		weight *= weight;	//squared falloff

		vec3 sampleN = 2 * texture(sampler2D(normalTexture, g_sampler_linearRepeat), sampleUV).rgb - 1;
		float NoN = max(dot(N, sampleN), 0);
		weight *= NoN;

		if(weight > 0){

			float edgeLod = 5.f;
			float edgeStrength = textureLod(sampler2D(edgeTexture, g_sampler_linearClamp), sampleUV, edgeLod).r;
			float lodFactor = clamp(1 - sqrt(edgeStrength), 0, 1);
			//lodFactor = 

			float lodMax = 5.f;
			float lod = mix(0, lodMax, lodFactor);
			lod = 4;
			vec4 sample_Y_SH = textureLod(sampler2D(texture_Y_SH, g_sampler_linearClamp), sampleUV, lod);
			vec2 sample_CoCg = texture(sampler2D(texture_CoCg, g_sampler_linearClamp), sampleUV).rg;

			//invalid samples are marked by being set to infinity
			if(any(isnan(sample_Y_SH)) || any(isnan(sample_CoCg))){
				//sample is invalid, do nothing
			}
			else{
				result_Y_SH += weight * sample_Y_SH; 
				result_CoCg += weight * sample_CoCg;
				weightTotal += weight;
			}
		}
	}
	weightTotal = max(weightTotal, 0.00001f);

	result_Y_SH /= weightTotal;
	result_CoCg /= weightTotal;

	imageStore(imageOut_Y_SH, iUV, result_Y_SH);
	imageStore(imageOut_CoCg, iUV, vec4(result_CoCg, 0, 0));
}