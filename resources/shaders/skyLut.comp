#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "sky.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f) uniform image2D skyLut;
layout(set=1, binding = 1) uniform texture2D transmissionLut;
layout(set=1, binding = 2) uniform texture2D multiscatterLut;
layout(set=1, binding = 3) uniform sampler skySampler;

layout(set=1, binding = 4, std140) uniform atmosphereSettingsBuffer{
    AtmosphereSettings atmosphereSettings;
};

layout(set=1, binding = 5, std430) buffer lightBuffer{
    float previousFrameExposure;
    float sunStrengthExposed;
    float skyStrengthExposed;
}; 

float phaseGreenstein(float VoL, float g){
    return (1.f - g * g) / (4.f * 3.1415f * pow(1.f + g * g - 2.f * g * VoL, 1.5f));
}

//approximates greenstein, has sign error
float phaseSchlick(float VoL, float g){
    float k = 1.55f * g - 0.55f * g * g * g;
    return (1.f - k * k) / (4.f * 3.1415 * pow(1.f + k * VoL, 2.f));
}

float phaseRayleigh(float VoL){
    return 3.f / (16.f * 3.1415f) * (1.f + VoL * VoL);
}

float cornetteShanksPhase(float VoL, float g){
    float nominator = 3.f / (8.f * 3.1415f) * (1 - g * g) * (1 + VoL * VoL);
    float denominator = (2 + g * g) * pow(1 + g * g - 2 * g * VoL, 1.5f);
    return nominator / denominator;
}

float shadowRay(vec3 P, vec3 D, vec3 C, float earthRadius){
    vec3 L = C - P;
    float t_ca = dot(L, D);
    float d = sqrt(dot(L, L) - t_ca * t_ca);
    
    //earth intersection
    float t_hc_earth = sqrt(earthRadius * earthRadius - d * d);
    float t_earth = t_ca - t_hc_earth; 
    
    return t_earth > 0 ? 0 : 1; 
}

void main(){
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    
    float x = uv.x / float(imageSize(skyLut).x);
    float y = uv.y / float(imageSize(skyLut).y);
    
    vec3 V = fromSkyLut(vec2(x, y)); //from camera to sky
    
    vec3 earthCenter = vec3(0); 
    vec3 P = vec3(0, -atmosphereSettings.earthRadius - 0.02f, 0); //need to offset to avoid self intersection with earth
    Intersection intersection = rayEarthIntersection(P, V, earthCenter, atmosphereSettings.earthRadius, atmosphereSettings.atmosphereHeight);
      
    const int sampleCount = 30;
    float stepSize = intersection.distance / sampleCount; 

    vec3 L = g_sunDirection.xyz;
    
    float VoL = dot(V, L);
    float phaseRayleigh = phaseRayleigh(VoL);
    
    float g = 0.75f;
    float phaseMie = phaseGreenstein(VoL, g);
    phaseMie = cornetteShanksPhase(VoL, g);
    //phaseMie = phaseSchlick(-VoL, g);

    vec3 currentPosition = P;
    vec3 absorption = vec3(1.f);
    vec3 color = vec3(0);
    
    for(int i = 0; i < sampleCount; i++){
        
        currentPosition += stepSize * V;
        
        float currentHeight = distance(currentPosition, earthCenter) - atmosphereSettings.earthRadius;
         
        //light arriving at point
        vec2 lutUV = computeLutUV(currentHeight, atmosphereSettings.atmosphereHeight, currentPosition, earthCenter, L);
        vec3 transmission = texture(sampler2D(transmissionLut, skySampler), lutUV).rgb;
        vec3 incomingLight = sunStrengthExposed * transmission;
        incomingLight *= shadowRay(currentPosition, L, earthCenter, atmosphereSettings.earthRadius);
                
        AtmosphereCoefficients coefficients = calculateCoefficients(currentHeight, atmosphereSettings);
        
        //inscattering from light at point
        vec3 inscatteringRayleight = coefficients.scatterRayleigh * incomingLight * phaseRayleigh;
        vec3 inscatteringMie = coefficients.scatterMie * incomingLight * phaseMie;
        vec3 inscattering = inscatteringRayleight + inscatteringMie;
        
        vec3 scatterIntegral = integrateInscattering(inscattering, coefficients.extinction, stepSize);
        color += scatterIntegral * absorption;
         
        absorption *= exp(-coefficients.extinction * stepSize); 
        
        vec3 multiscattering = texture(sampler2D(multiscatterLut, skySampler), lutUV).rgb;
        color += multiscattering * incomingLight * (coefficients.scatterRayleigh + coefficients.scatterMie) * stepSize * transmission;
    }   
    imageStore(skyLut, uv, vec4(color, 0.f));
}