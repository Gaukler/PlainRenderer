#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "sky.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f) uniform image2D skyLut;
layout(set=1, binding = 1) uniform texture2D transmissionLut;
layout(set=1, binding = 2) uniform texture2D multiscatterLut;
layout(set=1, binding = 3) uniform sampler skySampler;

layout(set=1, binding = 4, std140) uniform atmosphereSettings{
    vec3 scatteringRayleighGround;
    float earthRadius;
    vec3 extinctionRayleighGround;
    float atmosphereHeight;
    vec3 ozoneExtinction;
    float scatteringMieGround;
    float extinctionMieGround;
};

layout(set=1, binding = 5, std430) buffer lightBuffer{
    float previousFrameExposure;
    float sunStrengthExposed;
    float skyStrengthExposed;
};

float phaseGreenstein(float VoL, float g){
    return (1.f - g * g) / (4.f * 3.1415f * pow(1.f + g * g - 2.f * g * VoL, 1.5f));
}

//approximates greenstein, has sign error
float phaseSchlick(float VoL, float g){
    float k = 1.55f * g - 0.55f * g * g * g;
    return (1.f - k * k) / (4.f * 3.1415 * pow(1.f + k * VoL, 2.f));
}

float phaseRayleigh(float VoL){
    return 3.f / (16.f * 3.1415f) * (1.f + VoL * VoL);
}

float cornetteShanksPhase(float VoL, float g){
    float nominator = 3.f / (8.f * 3.1415f) * (1 - g * g) * (1 + VoL * VoL);
    float denominator = (2 + g * g) * pow(1 + g * g - 2 * g * VoL, 1.5f);
    return nominator / denominator;
}

float shadowRay(vec3 P, vec3 D, vec3 C, float earthRadius){
    vec3 L = C - P;
    float t_ca = dot(L, D);
    float d = sqrt(dot(L, L) - t_ca * t_ca);
    
    //earth intersection
    float t_hc_earth = sqrt(earthRadius * earthRadius - d * d);
    float t_earth = t_ca - t_hc_earth; 
    
    return t_earth > 0 ? 0 : 1; 
}

void main(){
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    
    float x = uv.x / float(imageSize(skyLut).x);
    float y = uv.y / float(imageSize(skyLut).y);
    
    vec3 V = fromSkyLut(vec2(x, y)); //from camera to sky
    
    vec3 earthCenter = vec3(0); 
    vec3 P = vec3(0, -earthRadius - 0.02f, 0); //need to offset to avoid self intersection with earth
    Intersection intersection = rayEarthIntersection(P, V, earthCenter, earthRadius, atmosphereHeight);
    float pathLength = distance(intersection.pos, P); 
      
    const int sampleCount = 30;
    float stepSize = pathLength / sampleCount; 
    
    vec3 sun = vec3(sunStrengthExposed);
    vec3 L = g_sunDirection.xyz;
    
    vec3 earthAlbedo = vec3(0.3);
    vec3 earthHitNormal = normalize(intersection.pos - earthCenter);
    float earthNoL = clamp(dot(earthHitNormal, L), 0, 1);
    vec2 lutUV;
    lutUV.x = 0;
    vec3 up = normalize(intersection.pos - earthCenter);
    lutUV.y = dot(up, L) * 0.5 + 0.5;
    vec3 transmission = texture(sampler2D(transmissionLut, skySampler), lutUV).rgb;
    vec3 incomingLight = sun * transmission;
    vec3 earthLit = earthAlbedo / 3.1415 * incomingLight * earthNoL;
    vec3 color = intersection.hitEarth ? earthLit : vec3(0.f);
    color = vec3(0);
    
    float VoL = dot(V, L);
    float phaseRayleigh = phaseRayleigh(VoL);
    
    float g = 0.75f;
    float phaseMie = phaseGreenstein(VoL, g);
    phaseMie = cornetteShanksPhase(VoL, g);
    //phaseMie = phaseSchlick(-VoL, g);

    vec3 currentPosition = P;
    vec3 absorption = vec3(1.f);
    
    for(int i = 0; i < sampleCount; i++){
        float currentHeight = distance(currentPosition, earthCenter) - earthRadius;
         
        //light arriving at point
        vec2 lutUV;
        lutUV.x = currentHeight / atmosphereHeight;
        vec3 up = normalize(currentPosition - earthCenter);
        lutUV.y = dot(up, L) * 0.5 + 0.5;
        vec3 transmission = texture(sampler2D(transmissionLut, skySampler), lutUV).rgb;
        vec3 incomingLight = sun * transmission;
        incomingLight *= shadowRay(currentPosition, L, earthCenter, earthRadius);
        
        //absorption from segment
        float mieFactor = mieHeightFactor(currentHeight);
        float scatteringMieCo = scatteringMieGround * mieFactor;
        
        vec3 extinctionRayleigh = extinctionRayleighGround * rayleighHeightFactor(currentHeight);
        float extinctionMie = extinctionMieGround * mieFactor; 
        vec3 extinctionOzone = ozoneExtinction * ozoneHeightFactor(currentHeight);
        vec3 extinctionCo = (extinctionMie + extinctionRayleigh + extinctionOzone);
        
        //inscattering from light at point
        vec3 scatteringRayleighCo = scatteringRayleighGround * rayleighHeightFactor(currentHeight);
        vec3 inscatteringRayleight = scatteringRayleighCo * incomingLight * phaseRayleigh;
        
        vec3 inscatteringMie = scatteringMieCo * incomingLight * phaseMie;
        vec3 inscattering = inscatteringRayleight + inscatteringMie;
        
        vec3 scatterIntegral = (inscattering - inscattering * exp(-extinctionCo * stepSize)) / extinctionCo;
        color += scatterIntegral * absorption; 
        
        absorption *= exp(-extinctionCo * stepSize); 
        
        vec3 multiscattering = texture(sampler2D(multiscatterLut, skySampler), lutUV).rgb;
        color += multiscattering * incomingLight * (scatteringRayleighCo + scatteringMieCo) * stepSize * transmission;
        
        currentPosition += stepSize * V;
    }   
    imageStore(skyLut, uv, vec4(color, 0.f));
}