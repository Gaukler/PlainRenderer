#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "colorConversion.inc"
#include "temporalReprojection.inc"
#include "bicubicSampling.inc"

layout(constant_id = 0) const bool useClipping = false;
layout(constant_id = 1) const bool useMotionVectorDilation = false;
layout(constant_id = 2) const int historySampleTech = 0;

#define HISTORY_SAMPLING_BILINEAR 0
#define HISTORY_SAMPLING_BICUBIC_16_TAP 1
#define HISTORY_SAMPLING_BICUBIC_9_TAP 2
#define HISTORY_SAMPLING_BICUBIC_5_TAP 3
#define HISTORY_SAMPLING_BICUBIC_1_TAP 4

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0) 					uniform texture2D currentFrame;
layout(set=1, binding = 1, r11f_g11f_b10f) 	uniform image2D outputImage;
layout(set=1, binding = 2, r11f_g11f_b10f) 	uniform image2D historyBufferDst;
layout(set=1, binding = 3) 	                uniform texture2D historyBufferSrc;
layout(set=1, binding = 4) 	                uniform texture2D motionBuffer;
layout(set=1, binding = 5) 	                uniform texture2D depthBuffer;
layout(set=1, binding = 6)                  uniform sampler colorSampler;

float luminance(vec3 c){
    return dot(c, vec3(0.21f, 0.71f, 0.08f));
}

void main(){

	ivec2 iUV = ivec2(gl_GlobalInvocationID.xy);
    
	vec2 texelSize = 1.f / imageSize(outputImage).xy;
	vec2 uv = (iUV + 0.5) * texelSize; //+0.5 to shift to pixel center
    vec3[3][3] neighbourhood = sampleNeighbourhood(currentFrame, colorSampler, uv, texelSize);
	vec3[2] minMax = minMaxFromNeighbourhood(neighbourhood);
    
	vec3 currentColor = neighbourhood[1][1];

    vec2 motion;
    if(useMotionVectorDilation){ 
        motion = getClosestFragmentMotion(iUV, depthBuffer, motionBuffer, colorSampler); 
    }
    else{
        motion = texelFetch(sampler2D(motionBuffer, colorSampler), iUV, 0).rg;
    }
    
	vec3 historySample; 
	if(historySampleTech == HISTORY_SAMPLING_BILINEAR){ 
		vec2 uvReprojected = uv + motion;
		historySample = texture(sampler2D(historyBufferSrc, colorSampler), uvReprojected).rgb;
	} 
	else if(historySampleTech == HISTORY_SAMPLING_BICUBIC_16_TAP){
		vec2 uvReprojected = vec2(iUV) + 0.5f + motion * g_screenResolution;
		historySample = bicubicSample16Tap(historyBufferSrc, colorSampler, uvReprojected, texelSize);
	}
	else if(historySampleTech == HISTORY_SAMPLING_BICUBIC_9_TAP){
		vec2 uvReprojected = vec2(iUV) + 0.5f + motion * g_screenResolution;
		historySample = bicubicSample9Tap(historyBufferSrc, colorSampler, uvReprojected, texelSize);
	}  
	else if(historySampleTech == HISTORY_SAMPLING_BICUBIC_5_TAP){
		vec2 uvReprojected = vec2(iUV) + 0.5f + motion * g_screenResolution;
		historySample = bicubicSample5Tap(historyBufferSrc, colorSampler, uvReprojected, texelSize);
	}  
	else if(historySampleTech == HISTORY_SAMPLING_BICUBIC_1_TAP){
		vec2 uvReprojected = vec2(iUV) + 0.5f + motion * g_screenResolution;
		historySample = bicubicSample1Tap(historyBufferSrc, colorSampler, uvReprojected, texelSize, neighbourhood);
	}
	else{
		historySample = vec3(1, 0, 0);
	}

    if(useClipping){
        historySample = clipAABB(historySample, minMax[0], minMax[1]);
    }
    else{
        historySample = clamp(historySample, minMax[0], minMax[1]);
    }  
    
    //nan test, mainly a problem when resizing the buffers
    //clear previous frame buffer on resize instead of checking here
    if(isnan(historySample.x) || isnan(historySample.y) || isnan(historySample.z)){
        historySample = currentColor;
    }
    
	float blendFactor = 0.1f;
	if(g_cameraCut){
		blendFactor = 1.f;
	}
    vec3 color = mix(historySample, currentColor, blendFactor);

    imageStore(historyBufferDst, iUV, vec4(color, 1.f));    
	imageStore(outputImage, iUV, vec4(color, 1.f));
}