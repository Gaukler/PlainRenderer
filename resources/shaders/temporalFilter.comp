#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "colorConversion.inc"
#include "temporalReprojection.inc"
#include "bicubicSampling.inc"

layout(constant_id = 0) const bool useClipping = false;
layout(constant_id = 1) const bool useMotionVectorDilation = false;
layout(constant_id = 2) const bool useBicubicHistorySample = false;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0) 					uniform texture2D inputImage;
layout(set=1, binding = 1, r11f_g11f_b10f) 	uniform image2D outputImage;
layout(set=1, binding = 2, r11f_g11f_b10f) 	uniform image2D historyBufferDst;
layout(set=1, binding = 3) 	                uniform texture2D historyBufferSrc;
layout(set=1, binding = 4) 	                uniform texture2D motionBuffer;
layout(set=1, binding = 5) 	                uniform texture2D depthBuffer;
layout(set=1, binding = 6)                  uniform sampler colorSampler;

//from: "Temporal ReprojectionAnti-Aliasing in INSIDE"
//clips a point towards a target in a axis aligned bounding box
vec3 clipAABB(
    vec3 target,    //last frame color
    vec3 bbMin,     //bounding box min 
    vec3 bbMax      //bounding box max   
    )    
{   
    const vec3 epsilon = vec3(0.0001f);
    
    vec3 center = 0.5f * (bbMax + bbMin);
    vec3 extend = 0.5f * (bbMax - bbMin) + epsilon; //epsilon prevents divison by zero
    
    vec3 toTarget = target - center;
    vec3 toTargetNorm = toTarget / extend;
    vec3 toTargetNormAbs = abs(toTargetNorm);
    float maxComponent = max(toTargetNormAbs.x, max(toTargetNormAbs.y, toTargetNormAbs.z));

    if(maxComponent < 1.f){
        return target; //target in bounding box
    }
    else{
        return center + toTarget / maxComponent;
    }
}

float luminance(vec3 c){
    return dot(c, vec3(0.21f, 0.71f, 0.08f));
}

vec3[3][3] sampleNeighbourhood(vec2 uv, vec2 texelSize){
	vec3[3][3] neighbourhood;
	for(int x = -1; x <= 1; x++){
        for(int y = -1; y <= 1; y++){
			vec3 color = texture(sampler2D(inputImage, colorSampler), uv + texelSize * vec2(x, y)).rgb;
			neighbourhood[x+1][y+1] = color;
		}
	}
	return neighbourhood;
}

vec3[2] minMaxFromNeighbourhood(vec3[3][3] neighbourhood){
	vec3[2] minMax;
	minMax[0] = neighbourhood[0][0];
	minMax[1] = neighbourhood[0][0];
	for(int i = 0; i < 3; i++){
        for(int j = 0; j < 3; j++){
			minMax[0] = min(minMax[0], neighbourhood[i][j]);
			minMax[1] = max(minMax[1], neighbourhood[i][j]);
		}
	}
	return minMax;
}

void main(){

	ivec2 iUV = ivec2(gl_GlobalInvocationID.xy);
    
	vec2 texelSize = 1.f / imageSize(outputImage).xy;
	vec2 uv = (iUV + 0.5) * texelSize; //+0.5 to shift to pixel center
    vec3[3][3] neighbourhood = sampleNeighbourhood(uv, texelSize);
	vec3[2] minMax = minMaxFromNeighbourhood(neighbourhood);
    
	vec3 currentColor = neighbourhood[1][1];

    vec2 motion;
    if(useMotionVectorDilation){ 
        motion = getClosestFragmentMotion(iUV, depthBuffer, motionBuffer, colorSampler); 
    }
    else{
        motion = texelFetch(sampler2D(motionBuffer, colorSampler), iUV, 0).rg;
    }
    
	vec3 historySample; 
	if(useBicubicHistorySample){ 
		vec2 uvReprojected = vec2(iUV) + 0.5f + motion * g_screenResolution;
		historySample = bicubicSample(historyBufferSrc, colorSampler, uvReprojected, texelSize);
	} 
	else{
		vec2 uvReprojected = uv + motion;
		historySample = texture(sampler2D(historyBufferSrc, colorSampler), uvReprojected).rgb;
	}	

    if(useClipping){
        historySample = clipAABB(historySample, minMax[0], minMax[1]);
    }
    else{
        historySample = clamp(historySample, minMax[0], minMax[1]);
    }
    
    //nan test, mainly a problem when resizing the buffers
    //clear previous frame buffer on resize instead of checking here
    if(isnan(historySample.x) || isnan(historySample.y) || isnan(historySample.z)){
        historySample = currentColor;
    }
    
	float blendFactor = 0.1f;
	if(g_cameraCut){
		blendFactor = 1.f;
	}
    vec3 color = mix(historySample, currentColor, blendFactor);
    
    imageStore(historyBufferDst, iUV, vec4(color, 1.f));    
	imageStore(outputImage, iUV, vec4(color, 1.f));
    
}