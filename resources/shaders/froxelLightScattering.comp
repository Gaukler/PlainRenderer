#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "sunShadowCascades.inc"
#include "screenToWorld.inc"
#include "lightBuffer.inc"
#include "volumeShading.inc"
#include "luminance.inc"
#include "volumetricFroxelLighting.inc"

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(set=1, binding = 0, rgba16f) uniform image3D scatteringTransmittanceVolume;
layout(set=1, binding = 1) uniform texture2D sunShadowMap;

layout(set=1, binding = 2, std430) buffer sunShadowInfo{
    ShadowCascadeInfo sunShadowCascadeInfo;
};

layout(set=1, binding = 3, std430) buffer lightStorageBuffer{
    LightBuffer lightBuffer;
};

float uvToDepth(float uv){
	return maxVolumetricLightingDepth * uv;
}

void main(){
	uvec3 iUV = gl_GlobalInvocationID.xyz;
	uvec3 volumeRes = imageSize(scatteringTransmittanceVolume);
	if(any(greaterThanEqual(iUV, volumeRes))){
		return;
	}

	//calculate world position
	vec3 uv = (iUV + 0.5f) / volumeRes;
	vec3 ndc = 2.f * (uv - 0.5f);
	vec3 V = calculateViewDirectionFromPixel(ndc.xy, g_cameraForward.xyz, g_cameraUp.xyz, g_cameraRight.xyz, g_cameraTanFovHalf, g_cameraAspectRatio);

	vec3 posWorld = g_cameraPosition.xyz - V / dot(-V, g_cameraForward.xyz) * uvToDepth(uv.z);

	float shadow = simpleShadow(posWorld, sunShadowCascadeInfo.lightMatrices[2], sunShadowMap, g_sampler_nearestBlackBorder);
	vec3 sunLight = shadow * lightBuffer.sunColor.rgb * lightBuffer.sunStrengthExposed;

	vec3 L = g_sunDirection.xyz;
	float VoL = dot(V, L);
	float g = 0.8f;
    float phase = phaseGreenstein(VoL, g);

	vec3 scatteringCoefficient = vec3(1.f);
	float densityMultiplier = 0.015f;
	scatteringCoefficient *= densityMultiplier;

	vec3 inscattering = sunLight * phase * scatteringCoefficient;

	vec3 absorptionCoefficient = vec3(1.f);
	absorptionCoefficient *= densityMultiplier;
	vec3 extinctionCoefficient = scatteringCoefficient + absorptionCoefficient;
	float transmittance = computeLuminance(extinctionCoefficient);

	imageStore(scatteringTransmittanceVolume, ivec3(iUV), vec4(inscattering, transmittance));
}