#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "colorConversion.inc"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 0, r11f_g11f_b10f) 	uniform image2D framebuffer;
layout(set=1, binding = 1) 	                uniform texture2D previousFramebuffer;
layout(set=1, binding = 2) 	                uniform texture2D motionBuffer;
layout(set=1, binding = 3) 	                uniform texture2D depthBuffer;
layout(set=1, binding = 4)                  uniform sampler colorSampler;

//from: "Temporal ReprojectionAnti-Aliasing in INSIDE"
//clips a point towards a target in a axis aligned bounding box
vec3 clipAABB(
    vec3 bbMin,     //bounding box min 
    vec3 bbMax,     //bounding box max   
    vec3 target)    //last frame color
{   
    vec3 center = 0.5f * (bbMax + bbMin);
    vec3 extend = 0.5f * (bbMax - bbMin);
    
    vec3 toTarget = target - center;
    vec3 toTargetNorm = toTarget / max(extend, 0.0001f);
    vec3 toTargetNormAbs = abs(toTargetNorm);
    float maxComponent = max(toTargetNormAbs.x, max(toTargetNormAbs.y, toTargetNormAbs.z));
    
    if(maxComponent < 1.f){
        return target; //target in bounding box
    }
    else{
        return center + toTarget / maxComponent;
    }
}

float luminance(vec3 c){
    return dot(c, vec3(0.299f, 0.587f, 0.114f));
}

const bool useYCoCg = true;
vec3 sampleNeighbourhood(ivec2 uv){
    vec3 c = imageLoad(framebuffer, uv).rgb;
    if(useYCoCg){
        return linearToYCoCg(c);
    }
    else{
        return c;
    }
}

void main(){

	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
     
    vec3 currentColor = imageLoad(framebuffer, uv).rgb;
    
    //collect neighbourhood min/max to build AABB color box
    vec3 minC = currentColor;
    vec3 maxC = currentColor;
    
    if(useYCoCg){
        minC = linearToYCoCg(minC);
        maxC = linearToYCoCg(maxC);
    }
    
    
    vec3 mean = vec3(0.f);
    vec3 variance = vec3(0.f);
    
    for(int x = -1; x <= 1; x++){
        for(int y = -1; y <= 1; y++){
            vec3 c = sampleNeighbourhood(uv + ivec2(x, y));
            mean += c;
            
            minC = min(minC, c);
            maxC = max(maxC, c);
        }
    }
    mean *= 1.f / 9.f;
    
    for(int x = -1; x <= 1; x++){
        for(int y = -1; y <= 1; y++){
            vec3 c = sampleNeighbourhood(uv + ivec2(x, y));
            vec3 diff = mean - c;
            variance += diff * diff;
        }
    }
    variance *= 1.f / 9;
    variance = sqrt(variance);
    
    //dilate velocity buffer
    float closestDepth = 1;
    ivec2 closestDepthOffset = ivec2(0);
    
    //3x3 neighbourhood from Inside paper
    for(int x = -1; x <= 1; x++){
        for(int y = -1; y <= 1; y++){
            ivec2 offset = ivec2(x, y);
            float depth = texelFetch(sampler2D(depthBuffer, colorSampler), uv + offset, 0).r;
            if(depth < closestDepth){
                closestDepth = depth;
                closestDepthOffset = offset;
            }
        }
    }
    
    vec2 motion = texelFetch(sampler2D(motionBuffer, colorSampler), uv + closestDepthOffset, 0).rg;
    
    //last frame must be sampled linearly and motion vector requires sub-pixel precision
    //careful not to destroy motion vector precision by casting to ivec
    vec2 uvReprojected = (uv + vec2(0.5f)) / vec2(imageSize(framebuffer)) + motion;
    vec3 historySample = texture(sampler2D(previousFramebuffer, colorSampler), uvReprojected).rgb;
    
    if(useYCoCg){
        historySample = linearToYCoCg(historySample);
    }
    
    const bool useVariance = true;
    if(useVariance){
        float scale = 1.5;
        
        vec3 varianceMin = mean - variance * scale;
        vec3 varianceMax = mean + variance * scale;
        
        minC = max(varianceMin, minC);
        maxC = min(varianceMax, maxC);
    }
    historySample = clipAABB(minC, maxC, historySample);
    
    if(useYCoCg){
        historySample = YCoCgToLinear(historySample);
    }
    
    //nan test, mainly a problem when resizing the buffers
    //clear previous frame buffer on resize instead of checking here
    if(isnan(historySample.x) || isnan(historySample.y) || isnan(historySample.z)){
        historySample = currentColor;
    }
    
    ////luminance difference based blend weight from inside
    //float blendFactorMin = 0.03f;
    //float blendFactorMax = 0.12f;
    //
    //float lumaCurrent = luminance(currentColor);
    //float lumaLast = luminance(historySample);
    //
    //float samplesDifference = abs(lumaCurrent - lumaLast)  / max(max(lumaCurrent, lumaLast), 0.2f);
    //float weight = 1.f - samplesDifference;
    //float weightSqrd = clamp(weight * weight, 0, 1);
    //
    //float blendFactor = mix(blendFactorMin, blendFactorMax, weightSqrd);
    
    vec3 color = mix(historySample, currentColor, 0.1f);

	imageStore(framebuffer, uv, vec4(color, 1.f));
}