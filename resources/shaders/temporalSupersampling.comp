#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "global.inc"
#include "temporalReprojection.inc"

layout(constant_id = 0) const bool useTonemap = false;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set=1, binding = 1) uniform texture2D currentFrame;
layout(set=1, binding = 2) uniform texture2D lastFrame;
layout(set=1, binding = 3, r11f_g11f_b10f) 	uniform image2D targetImage;
layout(set=1, binding = 4) uniform texture2D velocityBuffer;
layout(set=1, binding = 5) uniform texture2D depthBuffer;
layout(set=1, binding = 6) uniform texture2D currentLuminanceTexture;
layout(set=1, binding = 7) uniform texture2D lastLuminanceTexture;

//returns absolute difference of scalar and each closest vector component
float minAbsoluteDifference(float s, vec4 v){
	return 
		min(abs(s) - abs(v.x),
		min(abs(s) - abs(v.y),
		min(abs(s) - abs(v.z),
			abs(s) - abs(v.w))));
}

float computeLuminanceBlockDifference(vec4 currentLuminance, vec4 lastLuminance){
	return 
		minAbsoluteDifference(currentLuminance.x, lastLuminance) +
		minAbsoluteDifference(currentLuminance.y, lastLuminance) +
		minAbsoluteDifference(currentLuminance.z, lastLuminance) +
		minAbsoluteDifference(currentLuminance.w, lastLuminance);
}

//see: "Filmic SMAA", page 126
//reject based on 2x2 block min luminance difference
bool acceptLastFrameSample(vec4 currentLuminance, vec4 lastLuminance){
	//return true;
	float threshold = 0.5f;
	float contrast = computeLuminanceBlockDifference(currentLuminance, lastLuminance);
	return contrast < threshold;
}

//no clamping or history sample rejection as no problems occured yet
//will probably have to revisit this after particle effects volumetric etc. are added that might cause artifacts
void main(){
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    
	vec2 texelSize = 1.f / g_screenResolution;
    vec2 uvSample = (uv + vec2(0.5f)) * texelSize;

	vec2 motion = getClosestFragmentMotion(uv, depthBuffer, velocityBuffer, g_sampler_linearClamp);

	vec2 uvSampleCurrent = uvSample;		
	vec2 uvSampleLast = uvSample + motion;	

    vec3 currentSample	= texture(sampler2D(currentFrame, g_sampler_linearClamp), uvSampleCurrent).rgb;
    vec3 lastSample		= texture(sampler2D(lastFrame, g_sampler_linearClamp), uvSampleLast).rgb;

	if(useTonemap){
		currentSample = tonemap(currentSample);
		lastSample = tonemap(lastSample);
	}

	vec4 currentLuminance = textureGather(sampler2D(currentLuminanceTexture, g_sampler_nearestClamp), uvSampleCurrent, 0);
	vec4 lastLuminance	  = textureGather(sampler2D(lastLuminanceTexture, g_sampler_nearestClamp), uvSampleLast, 0);

	bool acceptSample = acceptLastFrameSample(currentLuminance, lastLuminance);
	float blendFactor = acceptSample ? 0.5f : 0.f;
    vec3 color = mix(currentSample, lastSample, blendFactor);   
	
	if(useTonemap){
		color = tonemapReverse(color);
	}
	//color = acceptSample ? color : vec3(1, 0, 0);
	//color = vec3(computeLuminanceBlockDifference(currentLuminance, lastLuminance));
	imageStore(targetImage, uv, vec4(color, 1.f));
}