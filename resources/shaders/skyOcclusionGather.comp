#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(set=1, binding = 0, rgba16_snorm) 		uniform image3D occlusionVolume;
layout(set=1, binding = 1) 	                uniform texture2D skyShadowMap;
layout(set=1, binding = 2)                  uniform sampler shadowSampler;

layout(set=1, binding = 3, std140) uniform occlusionData{
	mat4 skyShadowMatrix;
    vec4 occlusionVolumeExtends;
    vec4 sampleDirection;
    vec4 occlusionVolumeOffset;
    float weight;
};

void main(){

	ivec3 uv = ivec3(gl_GlobalInvocationID);
    
    //shadow test
    float occlusion;
    vec3 unoccludedDirection = vec3(0);
    {
        //TODO: move texel size computation to CPU
        vec3 texelSize = vec3(imageSize(occlusionVolume)) / occlusionVolumeExtends.xyz;
        
        vec3 samplePos = uv;    //in range [0, res]
        samplePos += 0.5f;      //shift to texel center
        vec3 posWorld = samplePos / texelSize;          //stretch to range [0, extend]
        posWorld -= 0.5f * occlusionVolumeExtends.xyz;  //move to [-extend/2, extend/2]  
        posWorld += occlusionVolumeOffset.xyz;
        vec4 posLight = skyShadowMatrix * vec4(posWorld, 1.f);
        vec2 shadowUV = posLight.xy / posLight.w;
        shadowUV = shadowUV * 0.5f + 0.5f;
        //shadowUV.x = clamp(shadowUV.x, 0, 1);
        float shadowMapDepth = texture(sampler2D(skyShadowMap, shadowSampler), shadowUV).r;
        occlusion = posLight.z < shadowMapDepth ? 1 : 0;
        unoccludedDirection = posLight.z < shadowMapDepth ? -sampleDirection.xyz : vec3(0);
    }
    float pdfWithoutNoL = 1.f / (3.1415); //NoL reduced by ao NoL
    occlusion *= weight / pdfWithoutNoL;
    unoccludedDirection *= weight;
    
    vec4 current = imageLoad(occlusionVolume, uv);
    
    imageStore(occlusionVolume, uv, current + vec4(unoccludedDirection, occlusion));
}